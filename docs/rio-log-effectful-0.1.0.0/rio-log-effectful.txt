-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on Github at
--   <a>https://github.com/Lugendre/rio-log-effectful#readme</a>
@package rio-log-effectful
@version 0.1.0.0

module Effectful.Log.Static

-- | Given a <a>LogOptions</a> value, run the given function with the
--   specified <a>LogFunc</a>. A common way to use this function is:
--   
--   <pre>
--   let isVerbose = False -- get from the command line instead
--   logOptions' &lt;- logOptionsHandle stderr isVerbose
--   let logOptions = setLogUseTime True logOptions'
--   withLogFunc logOptions $ \lf -&gt; do
--     let app = App -- application specific environment
--           { appLogFunc = lf
--           , appOtherStuff = ...
--           }
--     runRIO app $ do
--       logInfo "Starting app"
--       myApp
--   </pre>
withLogFunc :: MonadUnliftIO m => LogOptions -> (LogFunc -> m a) -> m a

-- | Given a <a>LogOptions</a> value, returns both a new <a>LogFunc</a> and
--   a sub-routine that disposes it.
--   
--   Intended for use if you want to deal with the teardown of
--   <a>LogFunc</a> yourself, otherwise prefer the <a>withLogFunc</a>
--   function instead.
newLogFunc :: (MonadIO n, MonadIO m) => LogOptions -> n (LogFunc, m ())

-- | A logging function, wrapped in a newtype for better error messages.
--   
--   An implementation may choose any behavior of this value it wishes,
--   including printing to standard output or no action at all.
data () => LogFunc

-- | Provide the ability to log messages via <a>LogFunc</a> like
--   <a>RIO</a>.
data Log :: Effect

-- | Internal representations of statically dispatched effects.
data family StaticRep (e :: Effect)

-- | Create a <a>LogOptions</a> value from the given <a>Handle</a> and
--   whether to perform verbose logging or not. Individiual settings can be
--   overridden using appropriate <tt>set</tt> functions. Logging output is
--   guaranteed to be non-interleaved only for a UTF-8 <a>Handle</a> in a
--   multi-thread environment.
--   
--   When Verbose Flag is <tt>True</tt>, the following happens:
--   
--   <ul>
--   <li><tt>setLogVerboseFormat</tt> is called with <tt>True</tt></li>
--   <li><tt>setLogUseColor</tt> is called with <tt>True</tt> (except on
--   Windows)</li>
--   <li><tt>setLogUseLoc</tt> is called with <tt>True</tt></li>
--   <li><tt>setLogUseTime</tt> is called with <tt>True</tt></li>
--   <li><tt>setLogMinLevel</tt> is called with <tt>Debug</tt> log
--   level</li>
--   </ul>
logOptionsHandle :: MonadIO m => Handle -> Bool -> m LogOptions

-- | Run the <a>Log</a> effect.
runLogRaw :: IOE :> es => LogFunc -> Eff (Log : es) a -> Eff es a

-- | Run the <a>Log</a> effect with <a>withLogFunc</a>.
runLog :: forall es a. IOE :> es => LogOptions -> Eff (Log : es) a -> Eff es a

-- | Configuration for how to create a <a>LogFunc</a>. Intended to be used
--   with the <a>withLogFunc</a> function.
data () => LogOptions

-- | Set the minimum log level. Messages below this level will not be
--   printed.
--   
--   Default: in verbose mode, <a>LevelDebug</a>. Otherwise,
--   <a>LevelInfo</a>.
setLogMinLevel :: LogLevel -> LogOptions -> LogOptions

-- | Refer to <a>setLogMinLevel</a>. This modifier allows to alter the
--   verbose format value dynamically at runtime.
--   
--   Default: in verbose mode, <a>LevelDebug</a>. Otherwise,
--   <a>LevelInfo</a>.
setLogMinLevelIO :: IO LogLevel -> LogOptions -> LogOptions

-- | Use the verbose format for printing log messages.
--   
--   Default: follows the value of the verbose flag.
setLogVerboseFormat :: Bool -> LogOptions -> LogOptions

-- | Refer to <a>setLogVerboseFormat</a>. This modifier allows to alter the
--   verbose format value dynamically at runtime.
--   
--   Default: follows the value of the verbose flag.
setLogVerboseFormatIO :: IO Bool -> LogOptions -> LogOptions

-- | Do we treat output as a terminal. If <tt>True</tt>, we will enable
--   sticky logging functionality.
--   
--   Default: checks if the <tt>Handle</tt> provided to
--   <a>logOptionsHandle</a> is a terminal with <a>hIsTerminalDevice</a>.
setLogTerminal :: Bool -> LogOptions -> LogOptions

-- | Include the time when printing log messages.
--   
--   Default: <a>True</a> in debug mode, <a>False</a> otherwise.
setLogUseTime :: Bool -> LogOptions -> LogOptions

-- | Use ANSI color codes in the log output.
--   
--   Default: <a>True</a> if in verbose mode <i>and</i> the <a>Handle</a>
--   is a terminal device.
setLogUseColor :: Bool -> LogOptions -> LogOptions

-- | Use code location in the log output.
--   
--   Default: <a>True</a> if in verbose mode, <a>False</a> otherwise.
setLogUseLoc :: Bool -> LogOptions -> LogOptions

-- | Set format method for messages
--   
--   Default: <a>id</a>
setLogFormat :: (Utf8Builder -> Utf8Builder) -> LogOptions -> LogOptions

-- | ANSI color codes for <a>LogLevel</a> in the log output.
--   
--   Default: <a>LevelDebug</a> = "\ESC[32m" -- Green <a>LevelInfo</a> =
--   "\ESC[34m" -- Blue <a>LevelWarn</a> = "\ESC[33m" -- Yellow
--   <a>LevelError</a> = "\ESC[31m" -- Red <a>LevelOther</a> _ = "\ESC[35m"
--   -- Magenta
setLogLevelColors :: (LogLevel -> Utf8Builder) -> LogOptions -> LogOptions

-- | ANSI color codes for secondary content in the log output.
--   
--   Default: "\ESC[90m" -- Bright black (gray)
setLogSecondaryColor :: Utf8Builder -> LogOptions -> LogOptions

-- | ANSI color codes for accents in the log output. Accent colors are
--   indexed by <a>Int</a>.
--   
--   Default: <a>const</a> "\ESC[92m" -- Bright green, for all indicies
setLogAccentColors :: (Int -> Utf8Builder) -> LogOptions -> LogOptions

-- | Lifted <a>logDebug</a>.
logDebug :: (Log :> es, HasCallStack) => Utf8Builder -> Eff es ()

-- | Lifted <a>logInfo</a>.
logInfo :: (Log :> es, HasCallStack) => Utf8Builder -> Eff es ()

-- | Lifted <a>logWarn</a>.
logWarn :: (Log :> es, HasCallStack) => Utf8Builder -> Eff es ()

-- | Lifted <a>logError</a>.
logError :: (Log :> es, HasCallStack) => Utf8Builder -> Eff es ()

-- | Lifted <a>logOther</a>.
logOther :: (Log :> es, HasCallStack) => Text -> Utf8Builder -> Eff es ()

-- | Lifted <a>logSticky</a>.
logSticky :: (Log :> es, HasCallStack) => Utf8Builder -> Eff es ()

-- | Lifted <a>logStickyDone</a>.
logStickyDone :: (Log :> es, HasCallStack) => Utf8Builder -> Eff es ()

-- | Lifted <a>logDebugS</a>.
logDebugS :: (Log :> es, HasCallStack) => LogSource -> Utf8Builder -> Eff es ()

-- | Lifted <a>logInfoS</a>.
logInfoS :: (Log :> es, HasCallStack) => LogSource -> Utf8Builder -> Eff es ()

-- | Lifted <a>logWarnS</a>.
logWarnS :: (Log :> es, HasCallStack) => LogSource -> Utf8Builder -> Eff es ()

-- | Lifted <a>logErrorS</a>.
logErrorS :: (Log :> es, HasCallStack) => LogSource -> Utf8Builder -> Eff es ()

-- | Lifted <a>logOtherS</a>.
logOtherS :: (Log :> es, HasCallStack) => Text -> LogSource -> Utf8Builder -> Eff es ()

-- | Lifted <a>logGeneric</a>.
logGeneric :: (Log :> es, HasCallStack) => LogSource -> LogLevel -> Utf8Builder -> Eff es ()

-- | Create a <a>LogFunc</a> from the given function.
mkLogFunc :: (CallStack -> LogSource -> LogLevel -> Utf8Builder -> IO ()) -> LogFunc

-- | Create a <a>LogOptions</a> value which will store its data in memory.
--   This is primarily intended for testing purposes. This will return both
--   a <a>LogOptions</a> value and an <a>IORef</a> containing the resulting
--   <a>Builder</a> value.
--   
--   This will default to non-verbose settings and assume there is a
--   terminal attached. These assumptions can be overridden using the
--   appropriate <tt>set</tt> functions.
logOptionsMemory :: MonadIO m => m (IORef Builder, LogOptions)

-- | The log level of a message.
data () => LogLevel
LevelDebug :: LogLevel
LevelInfo :: LogLevel
LevelWarn :: LogLevel
LevelError :: LogLevel
LevelOther :: !Text -> LogLevel

-- | Where in the application a log message came from. Used for display
--   purposes only.
type LogSource = Text

-- | <a>CallStack</a>s are a lightweight method of obtaining a partial
--   call-stack at any point in the program.
--   
--   A function can request its call-site with the <a>HasCallStack</a>
--   constraint. For example, we can define
--   
--   <pre>
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   </pre>
--   
--   as a variant of <tt>putStrLn</tt> that will get its call-site and
--   print it, along with the string given as argument. We can access the
--   call-stack inside <tt>putStrLnWithCallStack</tt> with
--   <a>callStack</a>.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   putStrLnWithCallStack :: HasCallStack =&gt; String -&gt; IO ()
--   putStrLnWithCallStack msg = do
--     putStrLn msg
--     putStrLn (prettyCallStack callStack)
--   :}
--   </pre>
--   
--   Thus, if we call <tt>putStrLnWithCallStack</tt> we will get a
--   formatted call-stack alongside our string.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLnWithCallStack "hello"
--   hello
--   CallStack (from HasCallStack):
--     putStrLnWithCallStack, called at &lt;interactive&gt;:... in interactive:Ghci...
--   </pre>
--   
--   GHC solves <a>HasCallStack</a> constraints in three steps:
--   
--   <ol>
--   <li>If there is a <a>CallStack</a> in scope -- i.e. the enclosing
--   function has a <a>HasCallStack</a> constraint -- GHC will append the
--   new call-site to the existing <a>CallStack</a>.</li>
--   <li>If there is no <a>CallStack</a> in scope -- e.g. in the GHCi
--   session above -- and the enclosing definition does not have an
--   explicit type signature, GHC will infer a <a>HasCallStack</a>
--   constraint for the enclosing definition (subject to the monomorphism
--   restriction).</li>
--   <li>If there is no <a>CallStack</a> in scope and the enclosing
--   definition has an explicit type signature, GHC will solve the
--   <a>HasCallStack</a> constraint for the singleton <a>CallStack</a>
--   containing just the current call-site.</li>
--   </ol>
--   
--   <a>CallStack</a>s do not interact with the RTS and do not require
--   compilation with <tt>-prof</tt>. On the other hand, as they are built
--   up explicitly via the <a>HasCallStack</a> constraints, they will
--   generally not contain as much information as the simulated call-stacks
--   maintained by the RTS.
--   
--   A <a>CallStack</a> is a <tt>[(String, SrcLoc)]</tt>. The
--   <tt>String</tt> is the name of function that was called, the
--   <a>SrcLoc</a> is the call-site. The list is ordered with the most
--   recently called function at the head.
--   
--   NOTE: The intrepid user may notice that <a>HasCallStack</a> is just an
--   alias for an implicit parameter <tt>?callStack :: CallStack</tt>. This
--   is an implementation detail and <b>should not</b> be considered part
--   of the <a>CallStack</a> API, we may decide to change the
--   implementation in the future.
data () => CallStack

-- | Convert a <a>CallStack</a> value into a <a>Utf8Builder</a> indicating
--   the first source location.
--   
--   TODO Consider showing the entire call stack instead.
displayCallStack :: CallStack -> Utf8Builder

-- | Provide the ability to log messages via <a>GLogFunc</a> like
--   <a>RIO</a>.
data GLog msg :: Effect

-- | Run the <a>GLog</a> effect.
runGLogRaw :: IOE :> es => GLogFunc msg -> Eff (GLog msg : es) a -> Eff es a

-- | Lifted <a>glog</a>.
glog :: GLog msg :> es => msg -> Eff es ()

-- | A generic logger of some type <tt>msg</tt>.
--   
--   Your <tt>GLocFunc</tt> can re-use the existing classical logging
--   framework of RIO, and/or implement additional transforms, filters.
--   Alternatively, you may log to a JSON source in a database, or anywhere
--   else as needed. You can decide how to log levels or severities based
--   on the constructors in your type. You will normally determine this in
--   your main app entry point.
data () => GLogFunc msg

-- | Make a <a>GLogFunc</a> via classic <a>LogFunc</a>. Use this if you'd
--   like to log your generic data type via the classic RIO terminal
--   logger.
gLogFuncClassic :: (HasLogLevel msg, HasLogSource msg, Display msg) => LogFunc -> GLogFunc msg

-- | Make a custom generic logger. With this you could, for example, write
--   to a database or a log digestion service. For example:
--   
--   <pre>
--   mkGLogFunc (\stack msg -&gt; send (Data.Aeson.encode (JsonLog stack msg)))
--   </pre>
mkGLogFunc :: (CallStack -> msg -> IO ()) -> GLogFunc msg

-- | A vesion of <a>contramapMaybeGLogFunc</a> which supports filering.
contramapMaybeGLogFunc :: (a -> Maybe b) -> GLogFunc b -> GLogFunc a

-- | A contramap. Use this to wrap sub-loggers via <a>mapRIO</a>.
--   
--   If you are on base &gt; 4.12.0, you can just use <a>contramap</a>.
contramapGLogFunc :: (a -> b) -> GLogFunc b -> GLogFunc a

-- | Level, if any, of your logs. If unknown, use <tt>LogOther</tt>. Use
--   for your generic log data types that want to sit inside the classic
--   log framework.
class () => HasLogLevel msg
getLogLevel :: HasLogLevel msg => msg -> LogLevel

-- | Source of a log. This can be whatever you want. Use for your generic
--   log data types that want to sit inside the classic log framework.
class () => HasLogSource msg
getLogSource :: HasLogSource msg => msg -> LogSource
