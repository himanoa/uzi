-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An easy to use, performant extensible effects library.
--   
--   An easy to use, performant extensible effects library with seamless
--   integration with the existing Haskell ecosystem.
--   
--   This is the "batteries-included" variant. See the
--   <tt><a>effectful-core</a></tt> package if you need a more limited
--   dependency footprint or want to browse documentation of core modules.
@package effectful
@version 2.3.0.0


-- | Lifted <a>Control.Concurrent.Chan</a>.
module Effectful.Concurrent.Chan

-- | Provide the ability to run <a>Eff</a> computations concurrently in
--   multiple threads and communicate between them.
--   
--   <i>Warning:</i> unless you stick to high level functions from the
--   <a>withAsync</a> family, the <a>Concurrent</a> effect makes it
--   possible to escape the scope of any scoped effect operation. Consider
--   the following:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Effectful.Reader.Static as R
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; printAsk msg = liftIO . putStrLn . (msg ++) . (": " ++) =&lt;&lt; R.ask
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     runEff . R.runReader "GLOBAL" . runConcurrent $ do
--       a &lt;- R.local (const "LOCAL") $ do
--         a &lt;- async $ do
--           printAsk "child (first)"
--           threadDelay 20000
--           printAsk "child (second)"
--         threadDelay 10000
--         printAsk "parent (inside)"
--         pure a
--       printAsk "parent (outside)"
--       wait a
--   :}
--   child (first): LOCAL
--   parent (inside): LOCAL
--   parent (outside): GLOBAL
--   child (second): LOCAL
--   </pre>
--   
--   Note that the asynchronous computation doesn't respect the scope of
--   <a>local</a>, i.e. the child thread still behaves like it's inside the
--   <a>local</a> block, even though the parent thread already got out of
--   it.
--   
--   This is because the value provided by the <a>Reader</a> effect is
--   thread local, i.e. each thread manages its own version of it. For the
--   <a>Reader</a> it is the only reasonable behavior, it wouldn't be very
--   useful if its "read only" value was affected by calls to <a>local</a>
--   from its parent or child threads.
--   
--   However, the cut isn't so clear if it comes to effects that provide
--   access to a mutable state. That's why statically dispatched
--   <tt>State</tt> and <tt>Writer</tt> effects come in two flavors, local
--   and shared:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Effectful.State.Static.Local as SL
--   
--   &gt;&gt;&gt; :{
--     runEff . SL.execState "Hi" . runConcurrent $ do
--       replicateConcurrently_ 3 $ SL.modify (++ "!")
--   :}
--   "Hi"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Effectful.State.Static.Shared as SS
--   
--   &gt;&gt;&gt; :{
--     runEff . SS.execState "Hi" . runConcurrent $ do
--       replicateConcurrently_ 3 $ SS.modify (++ "!")
--   :}
--   "Hi!!!"
--   </pre>
--   
--   In the first example state updates made concurrently are not reflected
--   in the parent thread because the value is thread local, but in the
--   second example they are, because the value is shared.
data Concurrent :: Effect

-- | Run the <a>Concurrent</a> effect.
runConcurrent :: IOE :> es => Eff (Concurrent : es) a -> Eff es a

-- | <a>Chan</a> is an abstract type representing an unbounded FIFO
--   channel.
data () => Chan a

-- | Lifted <a>newChan</a>.
newChan :: Concurrent :> es => Eff es (Chan a)

-- | Lifted <a>writeChan</a>.
writeChan :: Concurrent :> es => Chan a -> a -> Eff es ()

-- | Lifted <a>readChan</a>.
readChan :: Concurrent :> es => Chan a -> Eff es a

-- | Lifted <a>dupChan</a>.
dupChan :: Concurrent :> es => Chan a -> Eff es (Chan a)

-- | Lifted <a>getChanContents</a>.
getChanContents :: Concurrent :> es => Chan a -> Eff es [a]

-- | Lifted <a>writeList2Chan</a>.
writeList2Chan :: Concurrent :> es => Chan a -> [a] -> Eff es ()


-- | Lifted <a>Control.Concurrent.Async</a>.
module Effectful.Concurrent.Async

-- | Provide the ability to run <a>Eff</a> computations concurrently in
--   multiple threads and communicate between them.
--   
--   <i>Warning:</i> unless you stick to high level functions from the
--   <a>withAsync</a> family, the <a>Concurrent</a> effect makes it
--   possible to escape the scope of any scoped effect operation. Consider
--   the following:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Effectful.Reader.Static as R
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; printAsk msg = liftIO . putStrLn . (msg ++) . (": " ++) =&lt;&lt; R.ask
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     runEff . R.runReader "GLOBAL" . runConcurrent $ do
--       a &lt;- R.local (const "LOCAL") $ do
--         a &lt;- async $ do
--           printAsk "child (first)"
--           threadDelay 20000
--           printAsk "child (second)"
--         threadDelay 10000
--         printAsk "parent (inside)"
--         pure a
--       printAsk "parent (outside)"
--       wait a
--   :}
--   child (first): LOCAL
--   parent (inside): LOCAL
--   parent (outside): GLOBAL
--   child (second): LOCAL
--   </pre>
--   
--   Note that the asynchronous computation doesn't respect the scope of
--   <a>local</a>, i.e. the child thread still behaves like it's inside the
--   <a>local</a> block, even though the parent thread already got out of
--   it.
--   
--   This is because the value provided by the <a>Reader</a> effect is
--   thread local, i.e. each thread manages its own version of it. For the
--   <a>Reader</a> it is the only reasonable behavior, it wouldn't be very
--   useful if its "read only" value was affected by calls to <a>local</a>
--   from its parent or child threads.
--   
--   However, the cut isn't so clear if it comes to effects that provide
--   access to a mutable state. That's why statically dispatched
--   <tt>State</tt> and <tt>Writer</tt> effects come in two flavors, local
--   and shared:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Effectful.State.Static.Local as SL
--   
--   &gt;&gt;&gt; :{
--     runEff . SL.execState "Hi" . runConcurrent $ do
--       replicateConcurrently_ 3 $ SL.modify (++ "!")
--   :}
--   "Hi"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Effectful.State.Static.Shared as SS
--   
--   &gt;&gt;&gt; :{
--     runEff . SS.execState "Hi" . runConcurrent $ do
--       replicateConcurrently_ 3 $ SS.modify (++ "!")
--   :}
--   "Hi!!!"
--   </pre>
--   
--   In the first example state updates made concurrently are not reflected
--   in the parent thread because the value is thread local, but in the
--   second example they are, because the value is shared.
data Concurrent :: Effect

-- | Run the <a>Concurrent</a> effect.
runConcurrent :: IOE :> es => Eff (Concurrent : es) a -> Eff es a

-- | An asynchronous action spawned by <a>async</a> or <a>withAsync</a>.
--   Asynchronous actions are executed in a separate thread, and operations
--   are provided for waiting for asynchronous actions to complete and
--   obtaining their results (see e.g. <a>wait</a>).
data () => Async a

-- | Lifted <a>withAsync</a>.
withAsync :: Concurrent :> es => Eff es a -> (Async a -> Eff es b) -> Eff es b

-- | Lifted <a>withAsyncBound</a>.
withAsyncBound :: Concurrent :> es => Eff es a -> (Async a -> Eff es b) -> Eff es b

-- | Lifted <a>withAsyncOn</a>.
withAsyncOn :: Concurrent :> es => Int -> Eff es a -> (Async a -> Eff es b) -> Eff es b

-- | Lifted <a>withAsyncWithUnmask</a>.
withAsyncWithUnmask :: Concurrent :> es => ((forall c. Eff es c -> Eff es c) -> Eff es a) -> (Async a -> Eff es b) -> Eff es b

-- | Lifted <a>withAsyncOnWithUnmask</a>.
withAsyncOnWithUnmask :: Concurrent :> es => Int -> ((forall c. Eff es c -> Eff es c) -> Eff es a) -> (Async a -> Eff es b) -> Eff es b

-- | Lifted <a>wait</a>.
wait :: Concurrent :> es => Async a -> Eff es a

-- | Lifted <a>poll</a>.
poll :: Concurrent :> es => Async a -> Eff es (Maybe (Either SomeException a))

-- | Lifted <a>waitCatch</a>.
waitCatch :: Concurrent :> es => Async a -> Eff es (Either SomeException a)

-- | Returns the <a>ThreadId</a> of the thread running the given
--   <a>Async</a>.
asyncThreadId :: Async a -> ThreadId

-- | Lifted <a>cancel</a>.
cancel :: Concurrent :> es => Async a -> Eff es ()

-- | Lifted <a>uninterruptibleCancel</a>.
uninterruptibleCancel :: Concurrent :> es => Async a -> Eff es ()

-- | Lifted <a>cancelWith</a>.
cancelWith :: (Exception e, Concurrent :> es) => Async a -> e -> Eff es ()

-- | The exception thrown by <a>cancel</a> to terminate a thread.
data () => AsyncCancelled
AsyncCancelled :: AsyncCancelled

-- | Compare two Asyncs that may have different types by their
--   <a>ThreadId</a>.
compareAsyncs :: Async a -> Async b -> Ordering

-- | Lifted <a>race</a>.
race :: Concurrent :> es => Eff es a -> Eff es b -> Eff es (Either a b)

-- | Lifted <a>race_</a>.
race_ :: Concurrent :> es => Eff es a -> Eff es b -> Eff es ()

-- | Lifted <a>concurrently</a>.
concurrently :: Concurrent :> es => Eff es a -> Eff es b -> Eff es (a, b)

-- | Lifted <a>concurrently_</a>.
concurrently_ :: Concurrent :> es => Eff es a -> Eff es b -> Eff es ()

-- | Lifted <a>mapConcurrently</a>.
mapConcurrently :: (Traversable f, Concurrent :> es) => (a -> Eff es b) -> f a -> Eff es (f b)

-- | Lifted <a>forConcurrently</a>.
forConcurrently :: (Traversable f, Concurrent :> es) => f a -> (a -> Eff es b) -> Eff es (f b)

-- | Lifted <a>mapConcurrently_</a>.
mapConcurrently_ :: (Foldable f, Concurrent :> es) => (a -> Eff es b) -> f a -> Eff es ()

-- | Lifted <a>forConcurrently_</a>.
forConcurrently_ :: (Foldable f, Concurrent :> es) => f a -> (a -> Eff es b) -> Eff es ()

-- | Lifted <a>replicateConcurrently</a>.
replicateConcurrently :: Concurrent :> es => Int -> Eff es a -> Eff es [a]

-- | Lifted <a>replicateConcurrently_</a>.
replicateConcurrently_ :: Concurrent :> es => Int -> Eff es a -> Eff es ()

-- | Lifted <a>Concurrently</a>.
newtype Concurrently es a
Concurrently :: Eff es a -> Concurrently es a
[runConcurrently] :: Concurrently es a -> Eff es a

-- | Lifted <a>Conc</a>.
data Conc :: [Effect] -> Type -> Type

-- | Lifted <a>conc</a>.
conc :: Eff es a -> Conc es a

-- | Lifted <a>runConc</a>.
runConc :: Concurrent :> es => Conc es a -> Eff es a

-- | Things that can go wrong in the structure of a <a>Conc</a>. These are
--   <i>programmer errors</i>.
data () => ConcException
EmptyWithNoAlternative :: ConcException

-- | Lifted <a>pooledMapConcurrentlyN</a>.
pooledMapConcurrentlyN :: (Concurrent :> es, Traversable t) => Int -> (a -> Eff es b) -> t a -> Eff es (t b)

-- | Lifted <a>pooledMapConcurrently</a>.
pooledMapConcurrently :: (Concurrent :> es, Traversable t) => (a -> Eff es b) -> t a -> Eff es (t b)

-- | Lifted <a>pooledMapConcurrentlyN</a>.
pooledMapConcurrentlyN_ :: (Concurrent :> es, Foldable f) => Int -> (a -> Eff es b) -> f a -> Eff es ()

-- | Lifted <a>pooledMapConcurrently_</a>.
pooledMapConcurrently_ :: (Concurrent :> es, Foldable f) => (a -> Eff es b) -> f a -> Eff es ()

-- | Lifted <a>pooledForConcurrentlyN</a>.
pooledForConcurrentlyN :: (Concurrent :> es, Traversable t) => Int -> t a -> (a -> Eff es b) -> Eff es (t b)

-- | Lifted <a>pooledForConcurrently</a>.
pooledForConcurrently :: (Concurrent :> es, Traversable t) => t a -> (a -> Eff es b) -> Eff es (t b)

-- | Lifted <a>pooledForConcurrentlyN</a>.
pooledForConcurrentlyN_ :: (Concurrent :> es, Foldable f) => Int -> f a -> (a -> Eff es b) -> Eff es ()

-- | Lifted <a>pooledForConcurrently_</a>.
pooledForConcurrently_ :: (Concurrent :> es, Foldable f) => f a -> (a -> Eff es b) -> Eff es ()

-- | Lifted <a>pooledReplicateConcurrentlyN</a>.
pooledReplicateConcurrentlyN :: Concurrent :> es => Int -> Int -> Eff es a -> Eff es [a]

-- | Lifted <a>pooledReplicateConcurrently</a>.
pooledReplicateConcurrently :: Concurrent :> es => Int -> Eff es a -> Eff es [a]

-- | Lifted <a>pooledReplicateConcurrentlyN_</a>.
pooledReplicateConcurrentlyN_ :: Concurrent :> es => Int -> Int -> Eff es a -> Eff es ()

-- | Lifted <a>pooledReplicateConcurrently_</a>.
pooledReplicateConcurrently_ :: Concurrent :> es => Int -> Eff es a -> Eff es ()

-- | A version of <a>wait</a> that can be used inside an STM transaction.
waitSTM :: Async a -> STM a

-- | A version of <a>poll</a> that can be used inside an STM transaction.
pollSTM :: Async a -> STM (Maybe (Either SomeException a))

-- | A version of <a>waitCatch</a> that can be used inside an STM
--   transaction.
waitCatchSTM :: Async a -> STM (Either SomeException a)

-- | Lifted <a>waitAny</a>.
waitAny :: Concurrent :> es => [Async a] -> Eff es (Async a, a)

-- | Lifted <a>waitAnyCatch</a>.
waitAnyCatch :: Concurrent :> es => [Async a] -> Eff es (Async a, Either SomeException a)

-- | Lifted <a>waitAnyCancel</a>.
waitAnyCancel :: Concurrent :> es => [Async a] -> Eff es (Async a, a)

-- | Lifted <a>waitAnyCatchCancel</a>.
waitAnyCatchCancel :: Concurrent :> es => [Async a] -> Eff es (Async a, Either SomeException a)

-- | Lifted <a>waitEither</a>.
waitEither :: Concurrent :> es => Async a -> Async b -> Eff es (Either a b)

-- | Lifted <a>waitEitherCatch</a>.
waitEitherCatch :: Concurrent :> es => Async a -> Async b -> Eff es (Either (Either SomeException a) (Either SomeException b))

-- | Lifted <a>waitEitherCancel</a>.
waitEitherCancel :: Concurrent :> es => Async a -> Async b -> Eff es (Either a b)

-- | Lifted <a>waitEitherCatchCancel</a>.
waitEitherCatchCancel :: Concurrent :> es => Async a -> Async b -> Eff es (Either (Either SomeException a) (Either SomeException b))

-- | Lifted <a>waitEither_</a>.
waitEither_ :: Concurrent :> es => Async a -> Async b -> Eff es ()

-- | Lifted <a>waitBoth</a>.
waitBoth :: Concurrent :> es => Async a -> Async b -> Eff es (a, b)

-- | A version of <a>waitAny</a> that can be used inside an STM
--   transaction.
waitAnySTM :: [Async a] -> STM (Async a, a)

-- | A version of <a>waitAnyCatch</a> that can be used inside an STM
--   transaction.
waitAnyCatchSTM :: [Async a] -> STM (Async a, Either SomeException a)

-- | A version of <a>waitEither</a> that can be used inside an STM
--   transaction.
waitEitherSTM :: Async a -> Async b -> STM (Either a b)

-- | A version of <a>waitEitherCatch</a> that can be used inside an STM
--   transaction.
waitEitherCatchSTM :: Async a -> Async b -> STM (Either (Either SomeException a) (Either SomeException b))

-- | A version of <a>waitEither_</a> that can be used inside an STM
--   transaction.
waitEitherSTM_ :: Async a -> Async b -> STM ()

-- | A version of <a>waitBoth</a> that can be used inside an STM
--   transaction.
waitBothSTM :: Async a -> Async b -> STM (a, b)

-- | Lifted <a>async</a>.
async :: Concurrent :> es => Eff es a -> Eff es (Async a)

-- | Lifted <a>asyncBound</a>.
asyncBound :: Concurrent :> es => Eff es a -> Eff es (Async a)

-- | Lifted <a>asyncOn</a>.
asyncOn :: Concurrent :> es => Int -> Eff es a -> Eff es (Async a)

-- | Lifted <a>asyncWithUnmask</a>.
asyncWithUnmask :: Concurrent :> es => ((forall b. Eff es b -> Eff es b) -> Eff es a) -> Eff es (Async a)

-- | Lifted <a>asyncOnWithUnmask</a>.
asyncOnWithUnmask :: Concurrent :> es => Int -> ((forall b. Eff es b -> Eff es b) -> Eff es a) -> Eff es (Async a)

-- | Lifted <a>link</a>.
link :: Concurrent :> es => Async a -> Eff es ()

-- | Lifted <a>linkOnly</a>.
linkOnly :: Concurrent :> es => (SomeException -> Bool) -> Async a -> Eff es ()

-- | Lifted <a>link2</a>.
link2 :: Concurrent :> es => Async a -> Async b -> Eff es ()

-- | Lifted <a>link2Only</a>.
link2Only :: Concurrent :> es => (SomeException -> Bool) -> Async a -> Async b -> Eff es ()
data () => ExceptionInLinkedThread
ExceptionInLinkedThread :: Async a -> SomeException -> ExceptionInLinkedThread
instance GHC.Base.Functor (Effectful.Concurrent.Async.Conc es)
instance GHC.Base.Functor (Effectful.Concurrent.Async.Concurrently es)
instance (Effectful.Concurrent.Effect.Concurrent Effectful.Internal.Effect.:> es) => GHC.Base.Applicative (Effectful.Concurrent.Async.Concurrently es)
instance (Effectful.Concurrent.Effect.Concurrent Effectful.Internal.Effect.:> es) => GHC.Base.Alternative (Effectful.Concurrent.Async.Concurrently es)
instance (Effectful.Concurrent.Effect.Concurrent Effectful.Internal.Effect.:> es, GHC.Base.Semigroup a) => GHC.Base.Semigroup (Effectful.Concurrent.Async.Concurrently es a)
instance (Effectful.Concurrent.Effect.Concurrent Effectful.Internal.Effect.:> es, GHC.Base.Monoid a) => GHC.Base.Monoid (Effectful.Concurrent.Async.Concurrently es a)
instance GHC.Base.Applicative (Effectful.Concurrent.Async.Conc es)
instance GHC.Base.Alternative (Effectful.Concurrent.Async.Conc es)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Effectful.Concurrent.Async.Conc es a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Effectful.Concurrent.Async.Conc es a)


-- | Lifted <a>Control.Concurrent</a>.
--   
--   For functions that spawn threads, the order of preference for their
--   usage is recommended as follows:
--   
--   1) High level functions from <a>Effectful.Concurrent.Async</a> such as
--   <a>withAsync</a>, <a>concurrently</a> or <a>mapConcurrently</a>.
--   
--   2) Low level functions from <a>Effectful.Concurrent.Async</a> such as
--   <a>async</a>.
--   
--   3) Low level functions from <a>Effectful.Concurrent</a> such as
--   <a>forkIO</a>.
module Effectful.Concurrent

-- | Provide the ability to run <a>Eff</a> computations concurrently in
--   multiple threads and communicate between them.
--   
--   <i>Warning:</i> unless you stick to high level functions from the
--   <a>withAsync</a> family, the <a>Concurrent</a> effect makes it
--   possible to escape the scope of any scoped effect operation. Consider
--   the following:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Effectful.Reader.Static as R
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; printAsk msg = liftIO . putStrLn . (msg ++) . (": " ++) =&lt;&lt; R.ask
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     runEff . R.runReader "GLOBAL" . runConcurrent $ do
--       a &lt;- R.local (const "LOCAL") $ do
--         a &lt;- async $ do
--           printAsk "child (first)"
--           threadDelay 20000
--           printAsk "child (second)"
--         threadDelay 10000
--         printAsk "parent (inside)"
--         pure a
--       printAsk "parent (outside)"
--       wait a
--   :}
--   child (first): LOCAL
--   parent (inside): LOCAL
--   parent (outside): GLOBAL
--   child (second): LOCAL
--   </pre>
--   
--   Note that the asynchronous computation doesn't respect the scope of
--   <a>local</a>, i.e. the child thread still behaves like it's inside the
--   <a>local</a> block, even though the parent thread already got out of
--   it.
--   
--   This is because the value provided by the <a>Reader</a> effect is
--   thread local, i.e. each thread manages its own version of it. For the
--   <a>Reader</a> it is the only reasonable behavior, it wouldn't be very
--   useful if its "read only" value was affected by calls to <a>local</a>
--   from its parent or child threads.
--   
--   However, the cut isn't so clear if it comes to effects that provide
--   access to a mutable state. That's why statically dispatched
--   <tt>State</tt> and <tt>Writer</tt> effects come in two flavors, local
--   and shared:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Effectful.State.Static.Local as SL
--   
--   &gt;&gt;&gt; :{
--     runEff . SL.execState "Hi" . runConcurrent $ do
--       replicateConcurrently_ 3 $ SL.modify (++ "!")
--   :}
--   "Hi"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Effectful.State.Static.Shared as SS
--   
--   &gt;&gt;&gt; :{
--     runEff . SS.execState "Hi" . runConcurrent $ do
--       replicateConcurrently_ 3 $ SS.modify (++ "!")
--   :}
--   "Hi!!!"
--   </pre>
--   
--   In the first example state updates made concurrently are not reflected
--   in the parent thread because the value is thread local, but in the
--   second example they are, because the value is shared.
data Concurrent :: Effect

-- | Run the <a>Concurrent</a> effect.
runConcurrent :: IOE :> es => Eff (Concurrent : es) a -> Eff es a

-- | Lifted <a>myThreadId</a>.
myThreadId :: Concurrent :> es => Eff es ThreadId

-- | Lifted <a>forkIO</a>.
forkIO :: Concurrent :> es => Eff es () -> Eff es ThreadId

-- | Lifted <a>forkFinally</a>.
forkFinally :: Concurrent :> es => Eff es a -> (Either SomeException a -> Eff es ()) -> Eff es ThreadId

-- | Lifted <a>forkIOWithUnmask</a>.
forkIOWithUnmask :: Concurrent :> es => ((forall a. Eff es a -> Eff es a) -> Eff es ()) -> Eff es ThreadId

-- | Lifted <a>killThread</a>.
killThread :: Concurrent :> es => ThreadId -> Eff es ()

-- | Lifted <a>throwTo</a>.
throwTo :: (Concurrent :> es, Exception e) => ThreadId -> e -> Eff es ()

-- | Lifted <a>forkOn</a>.
forkOn :: Concurrent :> es => Int -> Eff es () -> Eff es ThreadId

-- | Lifted <a>forkOnWithUnmask</a>.
forkOnWithUnmask :: Concurrent :> es => Int -> ((forall a. Eff es a -> Eff es a) -> Eff es ()) -> Eff es ThreadId

-- | Lifted <a>getNumCapabilities</a>.
getNumCapabilities :: Concurrent :> es => Eff es Int

-- | Lifted <a>setNumCapabilities</a>.
setNumCapabilities :: Concurrent :> es => Int -> Eff es ()

-- | Lifted <a>getNumProcessors</a>.
getNumProcessors :: Concurrent :> es => Eff es Int

-- | Lifted <a>threadCapability</a>.
threadCapability :: Concurrent :> es => ThreadId -> Eff es (Int, Bool)

-- | Lifted <a>yield</a>.
yield :: Concurrent :> es => Eff es ()

-- | Lifted <a>threadDelay</a>.
threadDelay :: Concurrent :> es => Int -> Eff es ()

-- | Lifted <a>threadWaitRead</a>.
threadWaitRead :: Concurrent :> es => Fd -> Eff es ()

-- | Lifted <a>threadWaitWrite</a>.
threadWaitWrite :: Concurrent :> es => Fd -> Eff es ()

-- | Lifted <a>threadWaitReadSTM</a>.
threadWaitReadSTM :: Concurrent :> es => Fd -> Eff es (STM (), Eff es ())

-- | Lifted <a>threadWaitWriteSTM</a>.
threadWaitWriteSTM :: Concurrent :> es => Fd -> Eff es (STM (), Eff es ())

-- | Lifted <a>forkOS</a>.
forkOS :: Concurrent :> es => Eff es () -> Eff es ThreadId

-- | Lifted <a>forkOSWithUnmask</a>.
forkOSWithUnmask :: Concurrent :> es => ((forall a. Eff es a -> Eff es a) -> Eff es ()) -> Eff es ThreadId

-- | Lifted <a>isCurrentThreadBound</a>.
isCurrentThreadBound :: Concurrent :> es => Eff es Bool

-- | Lifted <a>runInBoundThread</a>.
runInBoundThread :: Concurrent :> es => Eff es a -> Eff es a

-- | Lifted <a>runInUnboundThread</a>.
runInUnboundThread :: Concurrent :> es => Eff es a -> Eff es a

-- | Lifted <a>mkWeakThreadId</a>.
mkWeakThreadId :: Concurrent :> es => ThreadId -> Eff es (Weak ThreadId)

-- | <a>True</a> if bound threads are supported. If
--   <tt>rtsSupportsBoundThreads</tt> is <a>False</a>,
--   <a>isCurrentThreadBound</a> will always return <a>False</a> and both
--   <a>forkOS</a> and <a>runInBoundThread</a> will fail.
rtsSupportsBoundThreads :: Bool


-- | Lifted <a>Control.Concurrent.MVar</a>.
module Effectful.Concurrent.MVar

-- | Provide the ability to run <a>Eff</a> computations concurrently in
--   multiple threads and communicate between them.
--   
--   <i>Warning:</i> unless you stick to high level functions from the
--   <a>withAsync</a> family, the <a>Concurrent</a> effect makes it
--   possible to escape the scope of any scoped effect operation. Consider
--   the following:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Effectful.Reader.Static as R
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; printAsk msg = liftIO . putStrLn . (msg ++) . (": " ++) =&lt;&lt; R.ask
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     runEff . R.runReader "GLOBAL" . runConcurrent $ do
--       a &lt;- R.local (const "LOCAL") $ do
--         a &lt;- async $ do
--           printAsk "child (first)"
--           threadDelay 20000
--           printAsk "child (second)"
--         threadDelay 10000
--         printAsk "parent (inside)"
--         pure a
--       printAsk "parent (outside)"
--       wait a
--   :}
--   child (first): LOCAL
--   parent (inside): LOCAL
--   parent (outside): GLOBAL
--   child (second): LOCAL
--   </pre>
--   
--   Note that the asynchronous computation doesn't respect the scope of
--   <a>local</a>, i.e. the child thread still behaves like it's inside the
--   <a>local</a> block, even though the parent thread already got out of
--   it.
--   
--   This is because the value provided by the <a>Reader</a> effect is
--   thread local, i.e. each thread manages its own version of it. For the
--   <a>Reader</a> it is the only reasonable behavior, it wouldn't be very
--   useful if its "read only" value was affected by calls to <a>local</a>
--   from its parent or child threads.
--   
--   However, the cut isn't so clear if it comes to effects that provide
--   access to a mutable state. That's why statically dispatched
--   <tt>State</tt> and <tt>Writer</tt> effects come in two flavors, local
--   and shared:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Effectful.State.Static.Local as SL
--   
--   &gt;&gt;&gt; :{
--     runEff . SL.execState "Hi" . runConcurrent $ do
--       replicateConcurrently_ 3 $ SL.modify (++ "!")
--   :}
--   "Hi"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Effectful.State.Static.Shared as SS
--   
--   &gt;&gt;&gt; :{
--     runEff . SS.execState "Hi" . runConcurrent $ do
--       replicateConcurrently_ 3 $ SS.modify (++ "!")
--   :}
--   "Hi!!!"
--   </pre>
--   
--   In the first example state updates made concurrently are not reflected
--   in the parent thread because the value is thread local, but in the
--   second example they are, because the value is shared.
data Concurrent :: Effect

-- | Run the <a>Concurrent</a> effect.
runConcurrent :: IOE :> es => Eff (Concurrent : es) a -> Eff es a

-- | An <a>MVar</a> (pronounced "em-var") is a synchronising variable, used
--   for communication between concurrent threads. It can be thought of as
--   a box, which may be empty or full.
data () => MVar a

-- | Lifted <a>newEmptyMVar</a>.
newEmptyMVar :: Concurrent :> es => Eff es (MVar a)

-- | Lifted <a>newMVar</a>.
newMVar :: Concurrent :> es => a -> Eff es (MVar a)

-- | Lifted <a>takeMVar</a>.
takeMVar :: Concurrent :> es => MVar a -> Eff es a

-- | Lifted <a>putMVar</a>.
putMVar :: Concurrent :> es => MVar a -> a -> Eff es ()

-- | Lifted <a>readMVar</a>.
readMVar :: Concurrent :> es => MVar a -> Eff es a

-- | Lifted <a>swapMVar</a>.
swapMVar :: Concurrent :> es => MVar a -> a -> Eff es a

-- | Lifted <a>tryTakeMVar</a>.
tryTakeMVar :: Concurrent :> es => MVar a -> Eff es (Maybe a)

-- | Lifted <a>tryPutMVar</a>.
tryPutMVar :: Concurrent :> es => MVar a -> a -> Eff es Bool

-- | Lifted <a>isEmptyMVar</a>.
isEmptyMVar :: Concurrent :> es => MVar a -> Eff es Bool

-- | Lifted <a>withMVar</a>.
withMVar :: Concurrent :> es => MVar a -> (a -> Eff es b) -> Eff es b

-- | Lifted <a>withMVarMasked</a>.
withMVarMasked :: Concurrent :> es => MVar a -> (a -> Eff es b) -> Eff es b

-- | Lifted <a>modifyMVar</a>.
modifyMVar :: Concurrent :> es => MVar a -> (a -> Eff es (a, b)) -> Eff es b

-- | Lifted <a>modifyMVar_</a>.
modifyMVar_ :: Concurrent :> es => MVar a -> (a -> Eff es a) -> Eff es ()

-- | Lifted <a>modifyMVarMasked</a>.
modifyMVarMasked :: Concurrent :> es => MVar a -> (a -> Eff es (a, b)) -> Eff es b

-- | Lifted <a>modifyMVarMasked_</a>.
modifyMVarMasked_ :: Concurrent :> es => MVar a -> (a -> Eff es a) -> Eff es ()

-- | Lifted <a>tryReadMVar</a>.
tryReadMVar :: Concurrent :> es => MVar a -> Eff es (Maybe a)

-- | Lifted <a>mkWeakMVar</a>.
mkWeakMVar :: Concurrent :> es => MVar a -> Eff es () -> Eff es (Weak (MVar a))


-- | Lifted <a>Control.Concurrent.MVar</a> with operations that force
--   values put inside an <a>MVar</a> to WHNF.
module Effectful.Concurrent.MVar.Strict

-- | Provide the ability to run <a>Eff</a> computations concurrently in
--   multiple threads and communicate between them.
--   
--   <i>Warning:</i> unless you stick to high level functions from the
--   <a>withAsync</a> family, the <a>Concurrent</a> effect makes it
--   possible to escape the scope of any scoped effect operation. Consider
--   the following:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Effectful.Reader.Static as R
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; printAsk msg = liftIO . putStrLn . (msg ++) . (": " ++) =&lt;&lt; R.ask
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     runEff . R.runReader "GLOBAL" . runConcurrent $ do
--       a &lt;- R.local (const "LOCAL") $ do
--         a &lt;- async $ do
--           printAsk "child (first)"
--           threadDelay 20000
--           printAsk "child (second)"
--         threadDelay 10000
--         printAsk "parent (inside)"
--         pure a
--       printAsk "parent (outside)"
--       wait a
--   :}
--   child (first): LOCAL
--   parent (inside): LOCAL
--   parent (outside): GLOBAL
--   child (second): LOCAL
--   </pre>
--   
--   Note that the asynchronous computation doesn't respect the scope of
--   <a>local</a>, i.e. the child thread still behaves like it's inside the
--   <a>local</a> block, even though the parent thread already got out of
--   it.
--   
--   This is because the value provided by the <a>Reader</a> effect is
--   thread local, i.e. each thread manages its own version of it. For the
--   <a>Reader</a> it is the only reasonable behavior, it wouldn't be very
--   useful if its "read only" value was affected by calls to <a>local</a>
--   from its parent or child threads.
--   
--   However, the cut isn't so clear if it comes to effects that provide
--   access to a mutable state. That's why statically dispatched
--   <tt>State</tt> and <tt>Writer</tt> effects come in two flavors, local
--   and shared:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Effectful.State.Static.Local as SL
--   
--   &gt;&gt;&gt; :{
--     runEff . SL.execState "Hi" . runConcurrent $ do
--       replicateConcurrently_ 3 $ SL.modify (++ "!")
--   :}
--   "Hi"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Effectful.State.Static.Shared as SS
--   
--   &gt;&gt;&gt; :{
--     runEff . SS.execState "Hi" . runConcurrent $ do
--       replicateConcurrently_ 3 $ SS.modify (++ "!")
--   :}
--   "Hi!!!"
--   </pre>
--   
--   In the first example state updates made concurrently are not reflected
--   in the parent thread because the value is thread local, but in the
--   second example they are, because the value is shared.
data Concurrent :: Effect

-- | Run the <a>Concurrent</a> effect.
runConcurrent :: IOE :> es => Eff (Concurrent : es) a -> Eff es a

-- | An <a>MVar</a> (pronounced "em-var") is a synchronising variable, used
--   for communication between concurrent threads. It can be thought of as
--   a box, which may be empty or full.
data () => MVar a

-- | Lifted <a>newEmptyMVar</a>.
newEmptyMVar :: Concurrent :> es => Eff es (MVar a)

-- | Lifted <a>newMVar</a> that evaluates the value to WHNF.
newMVar :: Concurrent :> es => a -> Eff es (MVar a)

-- | Lifted <a>takeMVar</a>.
takeMVar :: Concurrent :> es => MVar a -> Eff es a

-- | Lifted <a>putMVar</a>.
putMVar :: Concurrent :> es => MVar a -> a -> Eff es ()

-- | Lifted <a>readMVar</a>.
readMVar :: Concurrent :> es => MVar a -> Eff es a

-- | Lifted <a>swapMVar</a> that evaluates the new value to WHNF.
swapMVar :: Concurrent :> es => MVar a -> a -> Eff es a

-- | Lifted <a>tryTakeMVar</a>.
tryTakeMVar :: Concurrent :> es => MVar a -> Eff es (Maybe a)

-- | Lifted <a>tryPutMVar</a> that evaluates the new value to WHNF.
tryPutMVar :: Concurrent :> es => MVar a -> a -> Eff es Bool

-- | Lifted <a>isEmptyMVar</a>.
isEmptyMVar :: Concurrent :> es => MVar a -> Eff es Bool

-- | Lifted <a>withMVar</a>.
withMVar :: Concurrent :> es => MVar a -> (a -> Eff es b) -> Eff es b

-- | Lifted <a>withMVarMasked</a>.
withMVarMasked :: Concurrent :> es => MVar a -> (a -> Eff es b) -> Eff es b

-- | Lifted <a>modifyMVar</a> that evaluates the new value to WHNF.
modifyMVar :: Concurrent :> es => MVar a -> (a -> Eff es (a, b)) -> Eff es b

-- | Lifted <a>modifyMVar_</a> that evaluates the new value to WHNF.
modifyMVar_ :: Concurrent :> es => MVar a -> (a -> Eff es a) -> Eff es ()

-- | Lifted <a>modifyMVarMasked</a> that evaluates the new value to WHNF.
modifyMVarMasked :: Concurrent :> es => MVar a -> (a -> Eff es (a, b)) -> Eff es b

-- | Lifted <a>modifyMVarMasked_</a> that evaluates the new value to WHNF.
modifyMVarMasked_ :: Concurrent :> es => MVar a -> (a -> Eff es a) -> Eff es ()

-- | Lifted <a>tryReadMVar</a>.
tryReadMVar :: Concurrent :> es => MVar a -> Eff es (Maybe a)

-- | Lifted <a>mkWeakMVar</a>.
mkWeakMVar :: Concurrent :> es => MVar a -> Eff es () -> Eff es (Weak (MVar a))


-- | Lifted <a>Control.Concurrent.QSem</a>.
module Effectful.Concurrent.QSem

-- | Provide the ability to run <a>Eff</a> computations concurrently in
--   multiple threads and communicate between them.
--   
--   <i>Warning:</i> unless you stick to high level functions from the
--   <a>withAsync</a> family, the <a>Concurrent</a> effect makes it
--   possible to escape the scope of any scoped effect operation. Consider
--   the following:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Effectful.Reader.Static as R
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; printAsk msg = liftIO . putStrLn . (msg ++) . (": " ++) =&lt;&lt; R.ask
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     runEff . R.runReader "GLOBAL" . runConcurrent $ do
--       a &lt;- R.local (const "LOCAL") $ do
--         a &lt;- async $ do
--           printAsk "child (first)"
--           threadDelay 20000
--           printAsk "child (second)"
--         threadDelay 10000
--         printAsk "parent (inside)"
--         pure a
--       printAsk "parent (outside)"
--       wait a
--   :}
--   child (first): LOCAL
--   parent (inside): LOCAL
--   parent (outside): GLOBAL
--   child (second): LOCAL
--   </pre>
--   
--   Note that the asynchronous computation doesn't respect the scope of
--   <a>local</a>, i.e. the child thread still behaves like it's inside the
--   <a>local</a> block, even though the parent thread already got out of
--   it.
--   
--   This is because the value provided by the <a>Reader</a> effect is
--   thread local, i.e. each thread manages its own version of it. For the
--   <a>Reader</a> it is the only reasonable behavior, it wouldn't be very
--   useful if its "read only" value was affected by calls to <a>local</a>
--   from its parent or child threads.
--   
--   However, the cut isn't so clear if it comes to effects that provide
--   access to a mutable state. That's why statically dispatched
--   <tt>State</tt> and <tt>Writer</tt> effects come in two flavors, local
--   and shared:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Effectful.State.Static.Local as SL
--   
--   &gt;&gt;&gt; :{
--     runEff . SL.execState "Hi" . runConcurrent $ do
--       replicateConcurrently_ 3 $ SL.modify (++ "!")
--   :}
--   "Hi"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Effectful.State.Static.Shared as SS
--   
--   &gt;&gt;&gt; :{
--     runEff . SS.execState "Hi" . runConcurrent $ do
--       replicateConcurrently_ 3 $ SS.modify (++ "!")
--   :}
--   "Hi!!!"
--   </pre>
--   
--   In the first example state updates made concurrently are not reflected
--   in the parent thread because the value is thread local, but in the
--   second example they are, because the value is shared.
data Concurrent :: Effect

-- | Run the <a>Concurrent</a> effect.
runConcurrent :: IOE :> es => Eff (Concurrent : es) a -> Eff es a

-- | <a>QSem</a> is a quantity semaphore in which the resource is acquired
--   and released in units of one. It provides guaranteed FIFO ordering for
--   satisfying blocked <a>waitQSem</a> calls.
--   
--   The pattern
--   
--   <pre>
--   bracket_ waitQSem signalQSem (...)
--   </pre>
--   
--   is safe; it never loses a unit of the resource.
data () => QSem

-- | Lifted <a>newQSem</a>.
newQSem :: Concurrent :> es => Int -> Eff es QSem

-- | Lifted <a>waitQSem</a>.
waitQSem :: Concurrent :> es => QSem -> Eff es ()

-- | Lifted <a>signalQSem</a>.
signalQSem :: Concurrent :> es => QSem -> Eff es ()


-- | Lifted <a>Control.Concurrent.QSemN</a>.
module Effectful.Concurrent.QSemN

-- | Provide the ability to run <a>Eff</a> computations concurrently in
--   multiple threads and communicate between them.
--   
--   <i>Warning:</i> unless you stick to high level functions from the
--   <a>withAsync</a> family, the <a>Concurrent</a> effect makes it
--   possible to escape the scope of any scoped effect operation. Consider
--   the following:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Effectful.Reader.Static as R
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; printAsk msg = liftIO . putStrLn . (msg ++) . (": " ++) =&lt;&lt; R.ask
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     runEff . R.runReader "GLOBAL" . runConcurrent $ do
--       a &lt;- R.local (const "LOCAL") $ do
--         a &lt;- async $ do
--           printAsk "child (first)"
--           threadDelay 20000
--           printAsk "child (second)"
--         threadDelay 10000
--         printAsk "parent (inside)"
--         pure a
--       printAsk "parent (outside)"
--       wait a
--   :}
--   child (first): LOCAL
--   parent (inside): LOCAL
--   parent (outside): GLOBAL
--   child (second): LOCAL
--   </pre>
--   
--   Note that the asynchronous computation doesn't respect the scope of
--   <a>local</a>, i.e. the child thread still behaves like it's inside the
--   <a>local</a> block, even though the parent thread already got out of
--   it.
--   
--   This is because the value provided by the <a>Reader</a> effect is
--   thread local, i.e. each thread manages its own version of it. For the
--   <a>Reader</a> it is the only reasonable behavior, it wouldn't be very
--   useful if its "read only" value was affected by calls to <a>local</a>
--   from its parent or child threads.
--   
--   However, the cut isn't so clear if it comes to effects that provide
--   access to a mutable state. That's why statically dispatched
--   <tt>State</tt> and <tt>Writer</tt> effects come in two flavors, local
--   and shared:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Effectful.State.Static.Local as SL
--   
--   &gt;&gt;&gt; :{
--     runEff . SL.execState "Hi" . runConcurrent $ do
--       replicateConcurrently_ 3 $ SL.modify (++ "!")
--   :}
--   "Hi"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Effectful.State.Static.Shared as SS
--   
--   &gt;&gt;&gt; :{
--     runEff . SS.execState "Hi" . runConcurrent $ do
--       replicateConcurrently_ 3 $ SS.modify (++ "!")
--   :}
--   "Hi!!!"
--   </pre>
--   
--   In the first example state updates made concurrently are not reflected
--   in the parent thread because the value is thread local, but in the
--   second example they are, because the value is shared.
data Concurrent :: Effect

-- | Run the <a>Concurrent</a> effect.
runConcurrent :: IOE :> es => Eff (Concurrent : es) a -> Eff es a

-- | <a>QSemN</a> is a quantity semaphore in which the resource is acquired
--   and released in units of one. It provides guaranteed FIFO ordering for
--   satisfying blocked <a>waitQSemN</a> calls.
--   
--   The pattern
--   
--   <pre>
--   bracket_ (waitQSemN n) (signalQSemN n) (...)
--   </pre>
--   
--   is safe; it never loses any of the resource.
data () => QSemN

-- | Lifted <a>newQSemN</a>.
newQSemN :: Concurrent :> es => Int -> Eff es QSemN

-- | Lifted <a>waitQSemN</a>.
waitQSemN :: Concurrent :> es => QSemN -> Int -> Eff es ()

-- | Lifted <a>signalQSemN</a>.
signalQSemN :: Concurrent :> es => QSemN -> Int -> Eff es ()


-- | Lifted <a>Control.Concurrent.STM</a>.
module Effectful.Concurrent.STM

-- | Provide the ability to run <a>Eff</a> computations concurrently in
--   multiple threads and communicate between them.
--   
--   <i>Warning:</i> unless you stick to high level functions from the
--   <a>withAsync</a> family, the <a>Concurrent</a> effect makes it
--   possible to escape the scope of any scoped effect operation. Consider
--   the following:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Effectful.Reader.Static as R
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; printAsk msg = liftIO . putStrLn . (msg ++) . (": " ++) =&lt;&lt; R.ask
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--     runEff . R.runReader "GLOBAL" . runConcurrent $ do
--       a &lt;- R.local (const "LOCAL") $ do
--         a &lt;- async $ do
--           printAsk "child (first)"
--           threadDelay 20000
--           printAsk "child (second)"
--         threadDelay 10000
--         printAsk "parent (inside)"
--         pure a
--       printAsk "parent (outside)"
--       wait a
--   :}
--   child (first): LOCAL
--   parent (inside): LOCAL
--   parent (outside): GLOBAL
--   child (second): LOCAL
--   </pre>
--   
--   Note that the asynchronous computation doesn't respect the scope of
--   <a>local</a>, i.e. the child thread still behaves like it's inside the
--   <a>local</a> block, even though the parent thread already got out of
--   it.
--   
--   This is because the value provided by the <a>Reader</a> effect is
--   thread local, i.e. each thread manages its own version of it. For the
--   <a>Reader</a> it is the only reasonable behavior, it wouldn't be very
--   useful if its "read only" value was affected by calls to <a>local</a>
--   from its parent or child threads.
--   
--   However, the cut isn't so clear if it comes to effects that provide
--   access to a mutable state. That's why statically dispatched
--   <tt>State</tt> and <tt>Writer</tt> effects come in two flavors, local
--   and shared:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Effectful.State.Static.Local as SL
--   
--   &gt;&gt;&gt; :{
--     runEff . SL.execState "Hi" . runConcurrent $ do
--       replicateConcurrently_ 3 $ SL.modify (++ "!")
--   :}
--   "Hi"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Effectful.State.Static.Shared as SS
--   
--   &gt;&gt;&gt; :{
--     runEff . SS.execState "Hi" . runConcurrent $ do
--       replicateConcurrently_ 3 $ SS.modify (++ "!")
--   :}
--   "Hi!!!"
--   </pre>
--   
--   In the first example state updates made concurrently are not reflected
--   in the parent thread because the value is thread local, but in the
--   second example they are, because the value is shared.
data Concurrent :: Effect

-- | Run the <a>Concurrent</a> effect.
runConcurrent :: IOE :> es => Eff (Concurrent : es) a -> Eff es a

-- | A monad supporting atomic memory transactions.
data () => STM a

-- | Lifted <a>atomically</a>.
atomically :: Concurrent :> es => STM a -> Eff es a

-- | Retry execution of the current memory transaction because it has seen
--   values in <a>TVar</a>s which mean that it should not continue (e.g.
--   the <a>TVar</a>s represent a shared buffer that is now empty). The
--   implementation may block the thread until one of the <a>TVar</a>s that
--   it has read from has been updated. (GHC only)
retry :: STM a

-- | Compose two alternative STM actions (GHC only).
--   
--   If the first action completes without retrying then it forms the
--   result of the <a>orElse</a>. Otherwise, if the first action retries,
--   then the second action is tried in its place. If both actions retry
--   then the <a>orElse</a> as a whole retries.
orElse :: STM a -> STM a -> STM a

-- | Check that the boolean condition is true and, if not, <a>retry</a>.
--   
--   In other words, <tt>check b = unless b retry</tt>.
check :: Bool -> STM ()

-- | A variant of <a>throw</a> that can only be used within the <a>STM</a>
--   monad.
--   
--   Throwing an exception in <tt>STM</tt> aborts the transaction and
--   propagates the exception. If the exception is caught via
--   <a>catchSTM</a>, only the changes enclosed by the catch are rolled
--   back; changes made outside of <a>catchSTM</a> persist.
--   
--   If the exception is not caught inside of the <a>STM</a>, it is
--   re-thrown by <a>atomically</a>, and the entire <a>STM</a> is rolled
--   back.
--   
--   Although <a>throwSTM</a> has a type that is an instance of the type of
--   <a>throw</a>, the two functions are subtly different:
--   
--   <pre>
--   throw e    `seq` x  ===&gt; throw e
--   throwSTM e `seq` x  ===&gt; x
--   </pre>
--   
--   The first example will cause the exception <tt>e</tt> to be raised,
--   whereas the second one won't. In fact, <a>throwSTM</a> will only cause
--   an exception to be raised when it is used within the <a>STM</a> monad.
--   The <a>throwSTM</a> variant should be used in preference to
--   <a>throw</a> to raise an exception within the <a>STM</a> monad because
--   it guarantees ordering with respect to other <a>STM</a> operations,
--   whereas <a>throw</a> does not.
throwSTM :: Exception e => e -> STM a

-- | Exception handling within STM actions.
--   
--   <tt><a>catchSTM</a> m f</tt> catches any exception thrown by
--   <tt>m</tt> using <a>throwSTM</a>, using the function <tt>f</tt> to
--   handle the exception. If an exception is thrown, any changes made by
--   <tt>m</tt> are rolled back, but changes prior to <tt>m</tt> persist.
catchSTM :: Exception e => STM a -> (e -> STM a) -> STM a

-- | Shared memory locations that support atomic memory transactions.
data () => TVar a

-- | Lifted <a>newTVarIO</a>.
newTVarIO :: Concurrent :> es => a -> Eff es (TVar a)

-- | Lifted <a>readTVarIO</a>.
readTVarIO :: Concurrent :> es => TVar a -> Eff es a

-- | Create a new <a>TVar</a> holding a value supplied
newTVar :: a -> STM (TVar a)

-- | Return the current value stored in a <a>TVar</a>.
readTVar :: TVar a -> STM a

-- | Write the supplied value into a <a>TVar</a>.
writeTVar :: TVar a -> a -> STM ()

-- | Mutate the contents of a <a>TVar</a>. <i>N.B.</i>, this version is
--   non-strict.
modifyTVar :: TVar a -> (a -> a) -> STM ()

-- | Strict version of <a>modifyTVar</a>.
modifyTVar' :: TVar a -> (a -> a) -> STM ()

-- | Swap the contents of a <a>TVar</a> for a new value.
swapTVar :: TVar a -> a -> STM a

-- | Lifted <a>registerDelay</a>.
registerDelay :: Concurrent :> es => Int -> Eff es (TVar Bool)

-- | Lifted <a>mkWeakTVar</a>.
mkWeakTVar :: Concurrent :> es => TVar a -> Eff es () -> Eff es (Weak (TVar a))

-- | A <a>TMVar</a> is a synchronising variable, used for communication
--   between concurrent threads. It can be thought of as a box, which may
--   be empty or full.
data () => TMVar a

-- | Create a <a>TMVar</a> which contains the supplied value.
newTMVar :: a -> STM (TMVar a)

-- | Create a <a>TMVar</a> which is initially empty.
newEmptyTMVar :: STM (TMVar a)

-- | Lifted <a>newTMVarIO</a>.
newTMVarIO :: Concurrent :> es => a -> Eff es (TMVar a)

-- | Lifted <a>newEmptyTMVarIO</a>.
newEmptyTMVarIO :: Concurrent :> es => Eff es (TMVar a)

-- | Return the contents of the <a>TMVar</a>. If the <a>TMVar</a> is
--   currently empty, the transaction will <a>retry</a>. After a
--   <a>takeTMVar</a>, the <a>TMVar</a> is left empty.
takeTMVar :: TMVar a -> STM a

-- | Put a value into a <a>TMVar</a>. If the <a>TMVar</a> is currently
--   full, <a>putTMVar</a> will <a>retry</a>.
putTMVar :: TMVar a -> a -> STM ()

-- | This is a combination of <a>takeTMVar</a> and <a>putTMVar</a>; ie. it
--   takes the value from the <a>TMVar</a>, puts it back, and also returns
--   it.
readTMVar :: TMVar a -> STM a

-- | A version of <a>readTMVar</a> which does not retry. Instead it returns
--   <tt>Nothing</tt> if no value is available.
tryReadTMVar :: TMVar a -> STM (Maybe a)

-- | Swap the contents of a <a>TMVar</a> for a new value.
swapTMVar :: TMVar a -> a -> STM a

-- | A version of <a>takeTMVar</a> that does not <a>retry</a>. The
--   <a>tryTakeTMVar</a> function returns <a>Nothing</a> if the
--   <a>TMVar</a> was empty, or <tt><a>Just</a> a</tt> if the <a>TMVar</a>
--   was full with contents <tt>a</tt>. After <a>tryTakeTMVar</a>, the
--   <a>TMVar</a> is left empty.
tryTakeTMVar :: TMVar a -> STM (Maybe a)

-- | A version of <a>putTMVar</a> that does not <a>retry</a>. The
--   <a>tryPutTMVar</a> function attempts to put the value <tt>a</tt> into
--   the <a>TMVar</a>, returning <a>True</a> if it was successful, or
--   <a>False</a> otherwise.
tryPutTMVar :: TMVar a -> a -> STM Bool

-- | Check whether a given <a>TMVar</a> is empty.
isEmptyTMVar :: TMVar a -> STM Bool

-- | Lifted <a>mkWeakTMVar</a>.
mkWeakTMVar :: Concurrent :> es => TMVar a -> Eff es () -> Eff es (Weak (TMVar a))

-- | <a>TChan</a> is an abstract type representing an unbounded FIFO
--   channel.
data () => TChan a

-- | Build and return a new instance of <a>TChan</a>
newTChan :: STM (TChan a)

-- | Lifted <a>newTChanIO</a>.
newTChanIO :: Concurrent :> es => Eff es (TChan a)

-- | Create a write-only <a>TChan</a>. More precisely, <a>readTChan</a>
--   will <a>retry</a> even after items have been written to the channel.
--   The only way to read a broadcast channel is to duplicate it with
--   <a>dupTChan</a>.
--   
--   Consider a server that broadcasts messages to clients:
--   
--   <pre>
--   serve :: TChan Message -&gt; Client -&gt; IO loop
--   serve broadcastChan client = do
--       myChan &lt;- dupTChan broadcastChan
--       forever $ do
--           message &lt;- readTChan myChan
--           send client message
--   </pre>
--   
--   The problem with using <a>newTChan</a> to create the broadcast channel
--   is that if it is only written to and never read, items will pile up in
--   memory. By using <a>newBroadcastTChan</a> to create the broadcast
--   channel, items can be garbage collected after clients have seen them.
newBroadcastTChan :: STM (TChan a)

-- | Lifted <a>newBroadcastTChanIO</a>.
newBroadcastTChanIO :: Concurrent :> es => Eff es (TChan a)

-- | Duplicate a <a>TChan</a>: the duplicate channel begins empty, but data
--   written to either channel from then on will be available from both.
--   Hence this creates a kind of broadcast channel, where data written by
--   anyone is seen by everyone else.
dupTChan :: TChan a -> STM (TChan a)

-- | Clone a <a>TChan</a>: similar to dupTChan, but the cloned channel
--   starts with the same content available as the original channel.
cloneTChan :: TChan a -> STM (TChan a)

-- | Read the next value from the <a>TChan</a>.
readTChan :: TChan a -> STM a

-- | A version of <a>readTChan</a> which does not retry. Instead it returns
--   <tt>Nothing</tt> if no value is available.
tryReadTChan :: TChan a -> STM (Maybe a)

-- | Get the next value from the <tt>TChan</tt> without removing it,
--   retrying if the channel is empty.
peekTChan :: TChan a -> STM a

-- | A version of <a>peekTChan</a> which does not retry. Instead it returns
--   <tt>Nothing</tt> if no value is available.
tryPeekTChan :: TChan a -> STM (Maybe a)

-- | Write a value to a <a>TChan</a>.
writeTChan :: TChan a -> a -> STM ()

-- | Put a data item back onto a channel, where it will be the next item
--   read.
unGetTChan :: TChan a -> a -> STM ()

-- | Returns <a>True</a> if the supplied <a>TChan</a> is empty.
isEmptyTChan :: TChan a -> STM Bool

-- | <a>TQueue</a> is an abstract type representing an unbounded FIFO
--   channel.
data () => TQueue a

-- | Build and returns a new instance of <a>TQueue</a>
newTQueue :: STM (TQueue a)

-- | Lifted <a>newTQueueIO</a>.
newTQueueIO :: Concurrent :> es => Eff es (TQueue a)

-- | Read the next value from the <a>TQueue</a>.
readTQueue :: TQueue a -> STM a

-- | A version of <a>readTQueue</a> which does not retry. Instead it
--   returns <tt>Nothing</tt> if no value is available.
tryReadTQueue :: TQueue a -> STM (Maybe a)

-- | Get the next value from the <tt>TQueue</tt> without removing it,
--   retrying if the channel is empty.
peekTQueue :: TQueue a -> STM a

-- | A version of <a>peekTQueue</a> which does not retry. Instead it
--   returns <tt>Nothing</tt> if no value is available.
tryPeekTQueue :: TQueue a -> STM (Maybe a)

-- | Efficiently read the entire contents of a <a>TQueue</a> into a list.
--   This function never retries.
flushTQueue :: TQueue a -> STM [a]

-- | Write a value to a <a>TQueue</a>.
writeTQueue :: TQueue a -> a -> STM ()

-- | Put a data item back onto a channel, where it will be the next item
--   read.
unGetTQueue :: TQueue a -> a -> STM ()

-- | Returns <a>True</a> if the supplied <a>TQueue</a> is empty.
isEmptyTQueue :: TQueue a -> STM Bool

-- | <a>TBQueue</a> is an abstract type representing a bounded FIFO
--   channel.
data () => TBQueue a

-- | Builds and returns a new instance of <a>TBQueue</a>.
newTBQueue :: Natural -> STM (TBQueue a)

-- | Lifted <a>newTBQueueIO</a>.
newTBQueueIO :: Concurrent :> es => Natural -> Eff es (TBQueue a)

-- | Read the next value from the <a>TBQueue</a>.
readTBQueue :: TBQueue a -> STM a

-- | A version of <a>readTBQueue</a> which does not retry. Instead it
--   returns <tt>Nothing</tt> if no value is available.
tryReadTBQueue :: TBQueue a -> STM (Maybe a)

-- | Get the next value from the <tt>TBQueue</tt> without removing it,
--   retrying if the channel is empty.
peekTBQueue :: TBQueue a -> STM a

-- | A version of <a>peekTBQueue</a> which does not retry. Instead it
--   returns <tt>Nothing</tt> if no value is available.
tryPeekTBQueue :: TBQueue a -> STM (Maybe a)

-- | Efficiently read the entire contents of a <a>TBQueue</a> into a list.
--   This function never retries.
flushTBQueue :: TBQueue a -> STM [a]

-- | Write a value to a <a>TBQueue</a>; blocks if the queue is full.
writeTBQueue :: TBQueue a -> a -> STM ()

-- | Put a data item back onto a channel, where it will be the next item
--   read. Blocks if the queue is full.
unGetTBQueue :: TBQueue a -> a -> STM ()

-- | Return the length of a <a>TBQueue</a>.
lengthTBQueue :: TBQueue a -> STM Natural

-- | Returns <a>True</a> if the supplied <a>TBQueue</a> is empty.
isEmptyTBQueue :: TBQueue a -> STM Bool

-- | Returns <a>True</a> if the supplied <a>TBQueue</a> is full.
isFullTBQueue :: TBQueue a -> STM Bool


-- | Lifted functions from <a>Data.ByteString.Lazy.Char8</a> that are
--   related to standard streams. Like the original module, you probably
--   want to import this module qualified to avoid name clashes with the
--   functions provided by <a>Prelude</a>, e.g.:
--   
--   <pre>
--   import Data.ByteString.Lazy.Char8 (ByteString)
--   import qualified Data.ByteString.Lazy.Char8 as LBS8
--   import Effectful.Console.ByteString.Lazy (Console)
--   import qualified Effectful.Console.ByteString.Lazy as Console
--   </pre>
module Effectful.Console.ByteString.Lazy

-- | An effect for reading from/writing to <a>stdin</a>, <a>stdout</a> or
--   <a>stderr</a>.
data Console :: Effect

-- | Run the <a>Console</a> effect.
runConsole :: IOE :> es => Eff (Console : es) a -> Eff es a

-- | Lifted <a>getContents</a>.
getContents :: Console :> es => Eff es ByteString

-- | Lifted <a>putStr</a>.
putStr :: Console :> es => ByteString -> Eff es ()

-- | Lifted <a>putStrLn</a>.
putStrLn :: Console :> es => ByteString -> Eff es ()

-- | Lifted <a>interact</a>.
interact :: Console :> es => (ByteString -> ByteString) -> Eff es ()


-- | Lifted functions from <a>Data.ByteString.Char8</a> that are related to
--   standard streams. Like the original module, you probably want to
--   import this module qualified to avoid name clashes with the functions
--   provided by <a>Prelude</a>, e.g.:
--   
--   <pre>
--   import Data.ByteString (ByteString)
--   import qualified Data.ByteString.Char8 as BS8
--   import Effectful.Console.ByteString (Console)
--   import qualified Effectful.Console.ByteString as Console
--   </pre>
module Effectful.Console.ByteString

-- | An effect for reading from/writing to <a>stdin</a>, <a>stdout</a> or
--   <a>stderr</a>.
data Console :: Effect

-- | Run the <a>Console</a> effect.
runConsole :: IOE :> es => Eff (Console : es) a -> Eff es a

-- | Lifted <a>getLine</a>.
getLine :: Console :> es => Eff es ByteString

-- | Lifted <a>getContents</a>.
getContents :: Console :> es => Eff es ByteString

-- | Lifted <a>putStr</a>.
putStr :: Console :> es => ByteString -> Eff es ()

-- | Lifted <a>putStrLn</a>.
putStrLn :: Console :> es => ByteString -> Eff es ()

-- | Lifted <a>interact</a>.
interact :: Console :> es => (ByteString -> ByteString) -> Eff es ()

module Effectful.Environment

-- | An effect for querying and modifying the system environment.
data Environment :: Effect

-- | Run the <a>Environment</a> effect.
runEnvironment :: IOE :> es => Eff (Environment : es) a -> Eff es a

-- | Lifted <a>getArgs</a>.
getArgs :: Environment :> es => Eff es [String]

-- | Lifted <a>getProgName</a>.
getProgName :: Environment :> es => Eff es String

-- | Lifted <a>getExecutablePath</a>.
getExecutablePath :: Environment :> es => Eff es FilePath

-- | Lifted <a>getEnv</a>.
getEnv :: Environment :> es => String -> Eff es String

-- | Lifted <a>getEnvironment</a>.
getEnvironment :: Environment :> es => Eff es [(String, String)]

-- | Lifted <a>lookupEnv</a>.
lookupEnv :: Environment :> es => String -> Eff es (Maybe String)

-- | Lifted <a>setEnv</a>.
setEnv :: Environment :> es => String -> String -> Eff es ()

-- | Lifted <a>unsetEnv</a>.
unsetEnv :: Environment :> es => String -> Eff es ()

-- | Lifted <a>withArgs</a>.
withArgs :: Environment :> es => [String] -> Eff es a -> Eff es a

-- | Lifted <a>withProgName</a>.
withProgName :: Environment :> es => String -> Eff es a -> Eff es a

module Effectful.FileSystem

-- | An effect for interacting with the filesystem.
data FileSystem :: Effect

-- | Run the <a>FileSystem</a> effect.
runFileSystem :: IOE :> es => Eff (FileSystem : es) a -> Eff es a

-- | Lifted <a>createDirectory</a>.
createDirectory :: FileSystem :> es => FilePath -> Eff es ()

-- | Lifted <a>createDirectoryIfMissing</a>.
createDirectoryIfMissing :: FileSystem :> es => Bool -> FilePath -> Eff es ()

-- | Lifted <a>removeDirectory</a>.
removeDirectory :: FileSystem :> es => FilePath -> Eff es ()

-- | Lifted <a>removeDirectoryRecursive</a>.
removeDirectoryRecursive :: FileSystem :> es => FilePath -> Eff es ()

-- | Lifted <a>removePathForcibly</a>.
removePathForcibly :: FileSystem :> es => FilePath -> Eff es ()

-- | Lifted <a>renameDirectory</a>.
renameDirectory :: FileSystem :> es => FilePath -> FilePath -> Eff es ()

-- | Lifted <a>listDirectory</a>.
listDirectory :: FileSystem :> es => FilePath -> Eff es [FilePath]

-- | Lifted <a>getDirectoryContents</a>.
getDirectoryContents :: FileSystem :> es => FilePath -> Eff es [FilePath]

-- | Lifted <a>getCurrentDirectory</a>.
getCurrentDirectory :: FileSystem :> es => Eff es FilePath

-- | Lifted <a>setCurrentDirectory</a>.
setCurrentDirectory :: FileSystem :> es => FilePath -> Eff es ()

-- | Lifted <a>withCurrentDirectory</a>.
withCurrentDirectory :: FileSystem :> es => FilePath -> Eff es a -> Eff es a

-- | Lifted <a>getHomeDirectory</a>.
getHomeDirectory :: FileSystem :> es => Eff es FilePath

-- | Lifted <a>getXdgDirectory</a>.
getXdgDirectory :: FileSystem :> es => XdgDirectory -> FilePath -> Eff es FilePath

-- | Lifted <a>getXdgDirectoryList</a>.
getXdgDirectoryList :: FileSystem :> es => XdgDirectoryList -> Eff es [FilePath]

-- | Lifted <a>getAppUserDataDirectory</a>.
getAppUserDataDirectory :: FileSystem :> es => FilePath -> Eff es FilePath

-- | Lifted <a>getUserDocumentsDirectory</a>.
getUserDocumentsDirectory :: FileSystem :> es => Eff es FilePath

-- | Lifted <a>getTemporaryDirectory</a>.
getTemporaryDirectory :: FileSystem :> es => Eff es FilePath

-- | Lifted <a>removeFile</a>.
removeFile :: FileSystem :> es => FilePath -> Eff es ()

-- | Lifted <a>renameFile</a>.
renameFile :: FileSystem :> es => FilePath -> FilePath -> Eff es ()

-- | Lifted <a>renamePath</a>.
renamePath :: FileSystem :> es => FilePath -> FilePath -> Eff es ()

-- | Lifted <a>copyFile</a>.
copyFile :: FileSystem :> es => FilePath -> FilePath -> Eff es ()

-- | Lifted <a>copyFileWithMetadata</a>.
copyFileWithMetadata :: FileSystem :> es => FilePath -> FilePath -> Eff es ()

-- | Lifted <a>getFileSize</a>.
getFileSize :: FileSystem :> es => FilePath -> Eff es Integer

-- | Lifted <a>canonicalizePath</a>.
canonicalizePath :: FileSystem :> es => FilePath -> Eff es FilePath

-- | Lifted <a>makeAbsolute</a>.
makeAbsolute :: FileSystem :> es => FilePath -> Eff es FilePath

-- | Lifted <a>makeRelativeToCurrentDirectory</a>.
makeRelativeToCurrentDirectory :: FileSystem :> es => FilePath -> Eff es FilePath

-- | Lifted <a>doesPathExist</a>.
doesPathExist :: FileSystem :> es => FilePath -> Eff es Bool

-- | Lifted <a>doesFileExist</a>.
doesFileExist :: FileSystem :> es => FilePath -> Eff es Bool

-- | Lifted <a>doesDirectoryExist</a>.
doesDirectoryExist :: FileSystem :> es => FilePath -> Eff es Bool

-- | Lifted <a>findExecutable</a>.
findExecutable :: FileSystem :> es => String -> Eff es (Maybe FilePath)

-- | Lifted <a>findExecutables</a>.
findExecutables :: FileSystem :> es => String -> Eff es [FilePath]

-- | Lifted <a>findExecutablesInDirectories</a>.
findExecutablesInDirectories :: FileSystem :> es => [FilePath] -> String -> Eff es [FilePath]

-- | Lifted <a>findFile</a>.
findFile :: FileSystem :> es => [FilePath] -> String -> Eff es (Maybe FilePath)

-- | Lifted <a>findFiles</a>.
findFiles :: FileSystem :> es => [FilePath] -> String -> Eff es [FilePath]

-- | Lifted <a>findFileWith</a>.
findFileWith :: FileSystem :> es => (FilePath -> Eff es Bool) -> [FilePath] -> String -> Eff es (Maybe FilePath)

-- | Lifted <a>findFilesWith</a>.
findFilesWith :: FileSystem :> es => (FilePath -> Eff es Bool) -> [FilePath] -> String -> Eff es [FilePath]

-- | Lifted <a>createFileLink</a>.
createFileLink :: FileSystem :> es => FilePath -> FilePath -> Eff es ()

-- | Lifted <a>createDirectoryLink</a>.
createDirectoryLink :: FileSystem :> es => FilePath -> FilePath -> Eff es ()

-- | Lifted <a>removeDirectoryLink</a>.
removeDirectoryLink :: FileSystem :> es => FilePath -> Eff es ()

-- | Lifted <a>pathIsSymbolicLink</a>.
pathIsSymbolicLink :: FileSystem :> es => FilePath -> Eff es Bool

-- | Lifted <a>getSymbolicLinkTarget</a>.
getSymbolicLinkTarget :: FileSystem :> es => FilePath -> Eff es FilePath

-- | Lifted <a>getPermissions</a>.
getPermissions :: FileSystem :> es => FilePath -> Eff es Permissions

-- | Lifted <a>setPermissions</a>.
setPermissions :: FileSystem :> es => FilePath -> Permissions -> Eff es ()

-- | Lifted <a>copyPermissions</a>.
copyPermissions :: FileSystem :> es => FilePath -> FilePath -> Eff es ()

-- | Lifted <a>getAccessTime</a>.
getAccessTime :: FileSystem :> es => FilePath -> Eff es UTCTime

-- | Lifted <a>getModificationTime</a>.
getModificationTime :: FileSystem :> es => FilePath -> Eff es UTCTime

-- | Lifted <a>setAccessTime</a>.
setAccessTime :: FileSystem :> es => FilePath -> UTCTime -> Eff es ()

-- | Lifted <a>setModificationTime</a>.
setModificationTime :: FileSystem :> es => FilePath -> UTCTime -> Eff es ()

-- | Special directories for storing user-specific application data,
--   configuration, and cache files, as specified by the <a>XDG Base
--   Directory Specification</a>.
--   
--   Note: On Windows, <a>XdgData</a> and <a>XdgConfig</a> usually map to
--   the same directory.
data () => XdgDirectory

-- | For data files (e.g. images). It uses the <tt>XDG_DATA_HOME</tt>
--   environment variable. On non-Windows systems, the default is
--   <tt>~/.local/share</tt>. On Windows, the default is <tt>%APPDATA%</tt>
--   (e.g. <tt>C:/Users/<i>&lt;user&gt;</i>/AppData/Roaming</tt>). Can be
--   considered as the user-specific equivalent of <tt>/usr/share</tt>.
XdgData :: XdgDirectory

-- | For configuration files. It uses the <tt>XDG_CONFIG_HOME</tt>
--   environment variable. On non-Windows systems, the default is
--   <tt>~/.config</tt>. On Windows, the default is <tt>%APPDATA%</tt>
--   (e.g. <tt>C:/Users/<i>&lt;user&gt;</i>/AppData/Roaming</tt>). Can be
--   considered as the user-specific equivalent of <tt>/etc</tt>.
XdgConfig :: XdgDirectory

-- | For non-essential files (e.g. cache). It uses the
--   <tt>XDG_CACHE_HOME</tt> environment variable. On non-Windows systems,
--   the default is <tt>~/.cache</tt>. On Windows, the default is
--   <tt>%LOCALAPPDATA%</tt> (e.g.
--   <tt>C:/Users/<i>&lt;user&gt;</i>/AppData/Local</tt>). Can be
--   considered as the user-specific equivalent of <tt>/var/cache</tt>.
XdgCache :: XdgDirectory

-- | For data that should persist between (application) restarts, but that
--   is not important or portable enough to the user that it should be
--   stored in <a>XdgData</a>. It uses the <tt>XDG_STATE_HOME</tt>
--   environment variable. On non-Windows sytems, the default is
--   <tt>~/.local/state</tt>. On Windows, the default is
--   <tt>%LOCALAPPDATA%</tt> (e.g.
--   <tt>C:/Users/<i>&lt;user&gt;</i>/AppData/Local</tt>).
XdgState :: XdgDirectory

-- | Search paths for various application data, as specified by the <a>XDG
--   Base Directory Specification</a>.
--   
--   The list of paths is split using <a>searchPathSeparator</a>, which on
--   Windows is a semicolon.
--   
--   Note: On Windows, <a>XdgDataDirs</a> and <a>XdgConfigDirs</a> usually
--   yield the same result.
data () => XdgDirectoryList

-- | For data files (e.g. images). It uses the <tt>XDG_DATA_DIRS</tt>
--   environment variable. On non-Windows systems, the default is
--   <tt>/usr/local/share/</tt> and <tt>/usr/share/</tt>. On Windows, the
--   default is <tt>%PROGRAMDATA%</tt> or <tt>%ALLUSERSPROFILE%</tt> (e.g.
--   <tt>C:/ProgramData</tt>).
XdgDataDirs :: XdgDirectoryList

-- | For configuration files. It uses the <tt>XDG_CONFIG_DIRS</tt>
--   environment variable. On non-Windows systems, the default is
--   <tt>/etc/xdg</tt>. On Windows, the default is <tt>%PROGRAMDATA%</tt>
--   or <tt>%ALLUSERSPROFILE%</tt> (e.g. <tt>C:/ProgramData</tt>).
XdgConfigDirs :: XdgDirectoryList

-- | Filename extension for executable files (including the dot if any)
--   (usually <tt>""</tt> on POSIX systems and <tt>".exe"</tt> on Windows
--   or OS/2).
exeExtension :: String
data () => Permissions
emptyPermissions :: Permissions
readable :: Permissions -> Bool
writable :: Permissions -> Bool
executable :: Permissions -> Bool
searchable :: Permissions -> Bool
setOwnerReadable :: Bool -> Permissions -> Permissions
setOwnerWritable :: Bool -> Permissions -> Permissions
setOwnerExecutable :: Bool -> Permissions -> Permissions
setOwnerSearchable :: Bool -> Permissions -> Permissions


-- | Lifted <a>System.IO</a>.
module Effectful.FileSystem.IO

-- | An effect for interacting with the filesystem.
data FileSystem :: Effect

-- | Run the <a>FileSystem</a> effect.
runFileSystem :: IOE :> es => Eff (FileSystem : es) a -> Eff es a

-- | See <a>openFile</a>
data () => IOMode
ReadMode :: IOMode
WriteMode :: IOMode
AppendMode :: IOMode
ReadWriteMode :: IOMode

-- | Haskell defines operations to read and write characters from and to
--   files, represented by values of type <tt>Handle</tt>. Each value of
--   this type is a <i>handle</i>: a record used by the Haskell run-time
--   system to <i>manage</i> I/O with file system objects. A handle has at
--   least the following properties:
--   
--   <ul>
--   <li>whether it manages input or output or both;</li>
--   <li>whether it is <i>open</i>, <i>closed</i> or
--   <i>semi-closed</i>;</li>
--   <li>whether the object is seekable;</li>
--   <li>whether buffering is disabled, or enabled on a line or block
--   basis;</li>
--   <li>a buffer (whose length may be zero).</li>
--   </ul>
--   
--   Most handles will also have a current I/O position indicating where
--   the next input or output operation will occur. A handle is
--   <i>readable</i> if it manages only input or both input and output;
--   likewise, it is <i>writable</i> if it manages only output or both
--   input and output. A handle is <i>open</i> when first allocated. Once
--   it is closed it can no longer be used for either input or output,
--   though an implementation cannot re-use its storage while references
--   remain to it. Handles are in the <a>Show</a> and <a>Eq</a> classes.
--   The string produced by showing a handle is system dependent; it should
--   include enough information to identify the handle for debugging. A
--   handle is equal according to <a>==</a> only to itself; no attempt is
--   made to compare the internal state of different handles for equality.
data () => Handle
stdin :: Handle
stdout :: Handle
stderr :: Handle

-- | Lifted <a>withFile</a>.
withFile :: FileSystem :> es => FilePath -> IOMode -> (Handle -> Eff es a) -> Eff es a

-- | Lifted <a>withBinaryFile</a>.
withBinaryFile :: FileSystem :> es => FilePath -> IOMode -> (Handle -> Eff es a) -> Eff es a

-- | Lifted <a>openFile</a>
openFile :: FileSystem :> es => FilePath -> IOMode -> Eff es Handle

-- | Lifted <a>hClose</a>
hClose :: FileSystem :> es => Handle -> Eff es ()

-- | Lifted <a>hFlush</a>
hFlush :: FileSystem :> es => Handle -> Eff es ()

-- | Lifted <a>hFileSize</a>
hFileSize :: FileSystem :> es => Handle -> Eff es Integer

-- | Lifted <a>hSetFileSize</a>
hSetFileSize :: FileSystem :> es => Handle -> Integer -> Eff es ()

-- | Lifted <a>hIsEOF</a>
hIsEOF :: FileSystem :> es => Handle -> Eff es Bool

-- | Three kinds of buffering are supported: line-buffering,
--   block-buffering or no-buffering. These modes have the following
--   effects. For output, items are written out, or <i>flushed</i>, from
--   the internal buffer according to the buffer mode:
--   
--   <ul>
--   <li><i>line-buffering</i>: the entire output buffer is flushed
--   whenever a newline is output, the buffer overflows, a <a>hFlush</a> is
--   issued, or the handle is closed.</li>
--   <li><i>block-buffering</i>: the entire buffer is written out whenever
--   it overflows, a <a>hFlush</a> is issued, or the handle is closed.</li>
--   <li><i>no-buffering</i>: output is written immediately, and never
--   stored in the buffer.</li>
--   </ul>
--   
--   An implementation is free to flush the buffer more frequently, but not
--   less frequently, than specified above. The output buffer is emptied as
--   soon as it has been written out.
--   
--   Similarly, input occurs according to the buffer mode for the handle:
--   
--   <ul>
--   <li><i>line-buffering</i>: when the buffer for the handle is not
--   empty, the next item is obtained from the buffer; otherwise, when the
--   buffer is empty, characters up to and including the next newline
--   character are read into the buffer. No characters are available until
--   the newline character is available or the buffer is full.</li>
--   <li><i>block-buffering</i>: when the buffer for the handle becomes
--   empty, the next block of data is read into the buffer.</li>
--   <li><i>no-buffering</i>: the next input item is read and returned. The
--   <a>hLookAhead</a> operation implies that even a no-buffered handle may
--   require a one-character buffer.</li>
--   </ul>
--   
--   The default buffering mode when a handle is opened is
--   implementation-dependent and may depend on the file system object
--   which is attached to that handle. For most implementations, physical
--   files will normally be block-buffered and terminals will normally be
--   line-buffered.
data () => BufferMode

-- | buffering is disabled if possible.
NoBuffering :: BufferMode

-- | line-buffering should be enabled if possible.
LineBuffering :: BufferMode

-- | block-buffering should be enabled if possible. The size of the buffer
--   is <tt>n</tt> items if the argument is <a>Just</a> <tt>n</tt> and is
--   otherwise implementation-dependent.
BlockBuffering :: Maybe Int -> BufferMode

-- | Lifted <a>hSetBuffering</a>
hSetBuffering :: FileSystem :> es => Handle -> BufferMode -> Eff es ()

-- | Lifted <a>hGetBuffering</a>
hGetBuffering :: FileSystem :> es => Handle -> Eff es BufferMode

-- | Lifted <a>hSeek</a>
hSeek :: FileSystem :> es => Handle -> SeekMode -> Integer -> Eff es ()

-- | A mode that determines the effect of <a>hSeek</a> <tt>hdl mode i</tt>.
data () => SeekMode

-- | the position of <tt>hdl</tt> is set to <tt>i</tt>.
AbsoluteSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the
--   current position.
RelativeSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the end
--   of the file.
SeekFromEnd :: SeekMode

-- | Lifted <a>hTell</a>
hTell :: FileSystem :> es => Handle -> Eff es Integer

-- | Lifted <a>hIsOpen</a>
hIsOpen :: FileSystem :> es => Handle -> Eff es Bool

-- | Lifted <a>hIsClosed</a>
hIsClosed :: FileSystem :> es => Handle -> Eff es Bool

-- | Lifted <a>hIsReadable</a>
hIsReadable :: FileSystem :> es => Handle -> Eff es Bool

-- | Lifted <a>hIsWritable</a>
hIsWritable :: FileSystem :> es => Handle -> Eff es Bool

-- | Lifted <a>hIsSeekable</a>
hIsSeekable :: FileSystem :> es => Handle -> Eff es Bool

-- | Lifted <a>hIsTerminalDevice</a>
hIsTerminalDevice :: FileSystem :> es => Handle -> Eff es Bool

-- | Lifted <a>hSetEcho</a>
hSetEcho :: FileSystem :> es => Handle -> Bool -> Eff es ()

-- | Lifted <a>hGetEcho</a>
hGetEcho :: FileSystem :> es => Handle -> Eff es Bool

-- | Lifted <a>hWaitForInput</a>
hWaitForInput :: FileSystem :> es => Handle -> Int -> Eff es Bool

-- | Lifted <a>hReady</a>
hReady :: FileSystem :> es => Handle -> Eff es Bool


-- | Lifted <a>Data.ByteString</a>. Like the original module, you probably
--   want to import this module qualified to avoid name clashes with the
--   functions provided by <a>Prelude</a>, e.g.:
--   
--   <pre>
--   import Data.ByteString (ByteString)
--   import qualified Data.ByteString as BS
--   import qualified Effectful.FileSystem.IO.ByteString as EBS
--   </pre>
module Effectful.FileSystem.IO.ByteString

-- | Lifted <a>fromFilePath</a>.
fromFilePath :: FileSystem :> es => FilePath -> Eff es ByteString

-- | Lifted <a>toFilePath</a>.
toFilePath :: FileSystem :> es => ByteString -> Eff es FilePath

-- | Lifted <a>readFile</a>.
readFile :: FileSystem :> es => FilePath -> Eff es ByteString

-- | Lifted <a>writeFile</a>.
writeFile :: FileSystem :> es => FilePath -> ByteString -> Eff es ()

-- | Lifted <a>appendFile</a>.
appendFile :: FileSystem :> es => FilePath -> ByteString -> Eff es ()

-- | Lifted <a>hGetLine</a>.
hGetLine :: FileSystem :> es => Handle -> Eff es ByteString

-- | Lifted <a>hGetContents</a>.
hGetContents :: FileSystem :> es => Handle -> Eff es ByteString

-- | Lifted <a>hGet</a>.
hGet :: FileSystem :> es => Handle -> Int -> Eff es ByteString

-- | Lifted <a>hGetSome</a>.
hGetSome :: FileSystem :> es => Handle -> Int -> Eff es ByteString

-- | Lifted <a>hGetNonBlocking</a>.
hGetNonBlocking :: FileSystem :> es => Handle -> Int -> Eff es ByteString

-- | Lifted <a>hPut</a>.
hPut :: FileSystem :> es => Handle -> ByteString -> Eff es ()

-- | Lifted <a>hPutNonBlocking</a>.
hPutNonBlocking :: FileSystem :> es => Handle -> ByteString -> Eff es ByteString

-- | Lifted <a>hPutStr</a>.
hPutStr :: FileSystem :> es => Handle -> ByteString -> Eff es ()

-- | Lifted <a>hPutStrLn</a>.
hPutStrLn :: FileSystem :> es => Handle -> ByteString -> Eff es ()


-- | Lifted <a>Data.ByteString.Builder</a>. Like the original module, you
--   probably want to import this module qualified to avoid name clashes
--   with the functions provided by <a>Prelude</a>, e.g.:
--   
--   <pre>
--   import Data.ByteString.Builder (Builder)
--   import qualified Data.ByteString.Builder as BSB
--   import qualified Effectful.FileSystem.IO.ByteString.Builder as EBSB
--   </pre>
module Effectful.FileSystem.IO.ByteString.Builder

-- | Lifted <a>hPutBuilder</a>.
hPutBuilder :: FileSystem :> es => Handle -> Builder -> Eff es ()

-- | Lifted <a>writeFile</a>.
writeFile :: FileSystem :> es => FilePath -> Builder -> Eff es ()


-- | Lifted <a>Data.ByteString.Lazy.Char8</a>. Like the original module,
--   you probably want to import this module qualified to avoid name
--   clashes with the functions provided by <a>Prelude</a>, e.g.:
--   
--   <pre>
--   import Data.ByteString.Lazy (ByteString)
--   import qualified Data.ByteString.Lazy.Char8 as LBS8
--   import qualified Effectful.FileSystem.IO.ByteString.Lazy as ELBS
--   </pre>
module Effectful.FileSystem.IO.ByteString.Lazy

-- | Lifted <a>readFile</a>.
readFile :: FileSystem :> es => FilePath -> Eff es ByteString

-- | Lifted <a>writeFile</a>.
writeFile :: FileSystem :> es => FilePath -> ByteString -> Eff es ()

-- | Lifted <a>appendFile</a>.
appendFile :: FileSystem :> es => FilePath -> ByteString -> Eff es ()

-- | Lifted <a>hGetContents</a>.
hGetContents :: FileSystem :> es => Handle -> Eff es ByteString

-- | Lifted <a>hGet</a>.
hGet :: FileSystem :> es => Handle -> Int -> Eff es ByteString

-- | Lifted <a>hGetNonBlocking</a>.
hGetNonBlocking :: FileSystem :> es => Handle -> Int -> Eff es ByteString

-- | Lifted <a>hPut</a>.
hPut :: FileSystem :> es => Handle -> ByteString -> Eff es ()

-- | Lifted <a>hPutNonBlocking</a>.
hPutNonBlocking :: FileSystem :> es => Handle -> ByteString -> Eff es ByteString

-- | Lifted <a>hPutStr</a>.
hPutStr :: FileSystem :> es => Handle -> ByteString -> Eff es ()

-- | Lifted <a>hPutStrLn</a>.
hPutStrLn :: FileSystem :> es => Handle -> ByteString -> Eff es ()


-- | Lifted <a>UnliftIO.IO.File</a>.
module Effectful.FileSystem.IO.File

-- | Lifted <a>writeBinaryFile</a>.
writeBinaryFile :: FileSystem :> es => FilePath -> ByteString -> Eff es ()

-- | Lifted <a>writeBinaryFileAtomic</a>.
writeBinaryFileAtomic :: FileSystem :> es => FilePath -> ByteString -> Eff es ()

-- | Lifted <a>writeBinaryFileDurable</a>.
writeBinaryFileDurable :: FileSystem :> es => FilePath -> ByteString -> Eff es ()

-- | Lifted <a>writeBinaryFileDurableAtomic</a>.
writeBinaryFileDurableAtomic :: FileSystem :> es => FilePath -> ByteString -> Eff es ()

-- | Lifted <a>withBinaryFile</a>.
withBinaryFile :: FileSystem :> es => FilePath -> IOMode -> (Handle -> Eff es a) -> Eff es a

-- | Lifted <a>withBinaryFileAtomic</a>.
withBinaryFileAtomic :: FileSystem :> es => FilePath -> IOMode -> (Handle -> Eff es a) -> Eff es a

-- | Lifted <a>withBinaryFileDurable</a>.
withBinaryFileDurable :: FileSystem :> es => FilePath -> IOMode -> (Handle -> Eff es a) -> Eff es a

-- | Lifted <a>withBinaryFileDurableAtomic</a>.
withBinaryFileDurableAtomic :: FileSystem :> es => FilePath -> IOMode -> (Handle -> Eff es a) -> Eff es a

-- | Lifted <a>ensureFileDurable</a>.
ensureFileDurable :: FileSystem :> es => FilePath -> Eff es ()


-- | Lifted <a>System.Process</a>.
module Effectful.Process

-- | An effect for running child processes using the <tt>process</tt>
--   library.
data Process :: Effect
runProcess :: IOE :> es => Eff (Process : es) a -> Eff es a

-- | Lifted <a>createProcess</a>.
createProcess :: Process :> es => CreateProcess -> Eff es (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)

-- | Lifted <a>createProcess_</a>.
createProcess_ :: Process :> es => String -> CreateProcess -> Eff es (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)

-- | Construct a <a>CreateProcess</a> record for passing to
--   <a>createProcess</a>, representing a command to be passed to the
--   shell.
shell :: String -> CreateProcess

-- | Construct a <a>CreateProcess</a> record for passing to
--   <a>createProcess</a>, representing a raw command with arguments.
--   
--   See <a>RawCommand</a> for precise semantics of the specified
--   <tt>FilePath</tt>.
proc :: FilePath -> [String] -> CreateProcess
data () => CreateProcess
CreateProcess :: CmdSpec -> Maybe FilePath -> Maybe [(String, String)] -> StdStream -> StdStream -> StdStream -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Maybe GroupID -> Maybe UserID -> Bool -> CreateProcess

-- | Executable &amp; arguments, or shell command. If <a>cwd</a> is
--   <a>Nothing</a>, relative paths are resolved with respect to the
--   current working directory. If <a>cwd</a> is provided, it is
--   implementation-dependent whether relative paths are resolved with
--   respect to <a>cwd</a> or the current working directory, so absolute
--   paths should be used to ensure portability.
[cmdspec] :: CreateProcess -> CmdSpec

-- | Optional path to the working directory for the new process
[cwd] :: CreateProcess -> Maybe FilePath

-- | Optional environment (otherwise inherit from the current process)
[env] :: CreateProcess -> Maybe [(String, String)]

-- | How to determine stdin
[std_in] :: CreateProcess -> StdStream

-- | How to determine stdout
[std_out] :: CreateProcess -> StdStream

-- | How to determine stderr
[std_err] :: CreateProcess -> StdStream

-- | Close all file descriptors except stdin, stdout and stderr in the new
--   process (on Windows, only works if std_in, std_out, and std_err are
--   all Inherit). This implementation will call close on every fd from 3
--   to the maximum of open files, which can be slow for high maximum of
--   open files.
[close_fds] :: CreateProcess -> Bool

-- | Create a new process group
[create_group] :: CreateProcess -> Bool

-- | Delegate control-C handling. Use this for interactive console
--   processes to let them handle control-C themselves (see below for
--   details).
--   
--   On Windows this has no effect.
[delegate_ctlc] :: CreateProcess -> Bool

-- | Use the windows DETACHED_PROCESS flag when creating the process; does
--   nothing on other platforms.
[detach_console] :: CreateProcess -> Bool

-- | Use the windows CREATE_NEW_CONSOLE flag when creating the process;
--   does nothing on other platforms.
--   
--   Default: <tt>False</tt>
[create_new_console] :: CreateProcess -> Bool

-- | Use posix setsid to start the new process in a new session; does
--   nothing on other platforms.
[new_session] :: CreateProcess -> Bool

-- | Use posix setgid to set child process's group id; does nothing on
--   other platforms.
--   
--   Default: <tt>Nothing</tt>
[child_group] :: CreateProcess -> Maybe GroupID

-- | Use posix setuid to set child process's user id; does nothing on other
--   platforms.
--   
--   Default: <tt>Nothing</tt>
[child_user] :: CreateProcess -> Maybe UserID

-- | On Windows systems this flag indicates that we should wait for the
--   entire process tree to finish before unblocking. On POSIX systems this
--   flag is ignored. See $exec-on-windows for details.
--   
--   Default: <tt>False</tt>
[use_process_jobs] :: CreateProcess -> Bool
data () => CmdSpec

-- | A command line to execute using the shell
ShellCommand :: String -> CmdSpec

-- | The name of an executable with a list of arguments
--   
--   The <a>FilePath</a> argument names the executable, and is interpreted
--   according to the platform's standard policy for searching for
--   executables. Specifically:
--   
--   <ul>
--   <li>on Unix systems the <a>execvp(3)</a> semantics is used, where if
--   the executable filename does not contain a slash (<tt>/</tt>) then the
--   <tt>PATH</tt> environment variable is searched for the
--   executable.</li>
--   <li>on Windows systems the Win32 <tt>CreateProcess</tt> semantics is
--   used. Briefly: if the filename does not contain a path, then the
--   directory containing the parent executable is searched, followed by
--   the current directory, then some standard locations, and finally the
--   current <tt>PATH</tt>. An <tt>.exe</tt> extension is added if the
--   filename does not already have an extension. For full details see the
--   <a>documentation</a> for the Windows <tt>SearchPath</tt> API.</li>
--   </ul>
RawCommand :: FilePath -> [String] -> CmdSpec
data () => StdStream

-- | Inherit Handle from parent
Inherit :: StdStream

-- | Use the supplied Handle
UseHandle :: Handle -> StdStream

-- | Create a new pipe. The returned <tt>Handle</tt> will use the default
--   encoding and newline translation mode (just like <tt>Handle</tt>s
--   created by <tt>openFile</tt>).
CreatePipe :: StdStream

-- | Close the stream's file descriptor without passing a Handle. On POSIX
--   systems this may lead to strange behavior in the child process because
--   attempting to read or write after the file has been closed throws an
--   error. This should only be used with child processes that don't use
--   the file descriptor at all. If you wish to ignore the child process's
--   output you should either create a pipe and drain it manually or pass a
--   <tt>Handle</tt> that writes to <tt>/dev/null</tt>.
NoStream :: StdStream

-- | A handle to a process, which can be used to wait for termination of
--   the process using <a>waitForProcess</a>.
--   
--   None of the process-creation functions in this library wait for
--   termination: they all return a <a>ProcessHandle</a> which may be used
--   to wait for the process later.
--   
--   On Windows a second wait method can be used to block for event
--   completion. This requires two handles. A process job handle and a
--   events handle to monitor.
data () => ProcessHandle

-- | Lifted <a>callProcess</a>.
callProcess :: Process :> es => FilePath -> [String] -> Eff es ()

-- | Lifted <a>callCommand</a>.
callCommand :: Process :> es => String -> Eff es ()

-- | Lifted <a>spawnProcess</a>.
spawnProcess :: Process :> es => FilePath -> [String] -> Eff es ProcessHandle

-- | Lifted <a>spawnCommand</a>.
spawnCommand :: Process :> es => String -> Eff es ProcessHandle

-- | Lifted <a>readCreateProcess</a>.
readCreateProcess :: Process :> es => CreateProcess -> String -> Eff es String

-- | Lifted <a>readProcess</a>.
readProcess :: Process :> es => FilePath -> [String] -> String -> Eff es String

-- | Lifted <a>readCreateProcessWithExitCode</a>.
readCreateProcessWithExitCode :: Process :> es => CreateProcess -> String -> Eff es (ExitCode, String, String)

-- | Lifted <a>readProcessWithExitCode</a>.
readProcessWithExitCode :: Process :> es => FilePath -> [String] -> String -> Eff es (ExitCode, String, String)

-- | Lifted <a>withCreateProcess</a>.
withCreateProcess :: Process :> es => CreateProcess -> (Maybe Handle -> Maybe Handle -> Maybe Handle -> ProcessHandle -> Eff es a) -> Eff es a

-- | Lifted <a>cleanupProcess</a>.
cleanupProcess :: Process :> es => (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle) -> Eff es ()

-- | Given a program <tt><i>p</i></tt> and arguments <tt><i>args</i></tt>,
--   <tt>showCommandForUser <i>p</i> <i>args</i></tt> returns a string
--   suitable for pasting into <tt>/bin/sh</tt> (on Unix systems) or
--   <tt>CMD.EXE</tt> (on Windows).
showCommandForUser :: FilePath -> [String] -> String

-- | The platform specific type for a process identifier.
--   
--   This is always an integral type. Width and signedness are platform
--   specific.
type Pid = CPid

-- | Lifted <a>getPid</a>.
getPid :: Process :> es => ProcessHandle -> Eff es (Maybe Pid)

-- | Lifted <a>getCurrentPid</a>.
getCurrentPid :: Process :> es => Eff es Pid

-- | Lifted <a>waitForProcess</a>.
waitForProcess :: Process :> es => ProcessHandle -> Eff es ExitCode

-- | Lifted <a>getProcessExitCode</a>.
getProcessExitCode :: Process :> es => ProcessHandle -> Eff es (Maybe ExitCode)

-- | Lifted <a>terminateProcess</a>.
terminateProcess :: Process :> es => ProcessHandle -> Eff es ()

-- | Lifted <a>interruptProcessGroupOf</a>.
interruptProcessGroupOf :: Process :> es => ProcessHandle -> Eff es ()

-- | Lifted <a>createPipe</a>.
createPipe :: Process :> es => Eff es (Handle, Handle)

-- | Lifted <a>createPipeFd</a>.
createPipeFd :: Process :> es => Eff es (FD, FD)

module Effectful.Temporary

-- | An effect for interacting with temporary files.
data Temporary :: Effect

-- | Run the <a>Temporary</a> effect.
runTemporary :: IOE :> es => Eff (Temporary : es) a -> Eff es a

-- | Lifted <a>withSystemTempFile</a>.
withSystemTempFile :: Temporary :> es => String -> (FilePath -> Handle -> Eff es a) -> Eff es a

-- | Lifted <a>withSystemTempDirectory</a>.
withSystemTempDirectory :: Temporary :> es => String -> (FilePath -> Eff es a) -> Eff es a

-- | Lifted <a>withTempFile</a>.
withTempFile :: Temporary :> es => FilePath -> String -> (FilePath -> Handle -> Eff es a) -> Eff es a

-- | Lifted <a>withTempDirectory</a>.
withTempDirectory :: Temporary :> es => FilePath -> String -> (FilePath -> Eff es a) -> Eff es a

module Effectful.Timeout

-- | An effect for timing out computations.
data Timeout :: Effect

-- | Run the <a>Timeout</a> effect.
runTimeout :: IOE :> es => Eff (Timeout : es) a -> Eff es a

-- | Lifted <a>timeout</a>.
timeout :: Timeout :> es => Int -> Eff es a -> Eff es (Maybe a)
