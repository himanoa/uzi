-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | HTTP client library
--   
--   HTTP client library.
@package req
@version 3.13.2


-- | The documentation below is structured in such a way that the most
--   important information is presented first: you learn how to do HTTP
--   requests, how to embed them in the monad you have, and then it gives
--   you details about less-common things you may want to know about. The
--   documentation is written with sufficient coverage of details and
--   examples, and it's designed to be a complete tutorial on its own.
--   
--   <h3>About the library</h3>
--   
--   Req is an HTTP client library that attempts to be easy-to-use,
--   type-safe, and expandable.
--   
--   “Easy-to-use” means that the library is designed to be
--   beginner-friendly so it's simple to add to your monad stack, intuitive
--   to work with, well-documented, and does not get in your way. Doing
--   HTTP requests is a common task and a Haskell library for this should
--   be approachable and clear to beginners, thus certain compromises were
--   made. For example, one cannot currently modify <a>ManagerSettings</a>
--   of the default manager because the library always uses the same
--   implicit global manager for simplicity and maximal connection sharing.
--   There is a way to use your own manager with different settings, but it
--   requires more typing.
--   
--   “Type-safe” means that the library tries to eliminate certain classes
--   of errors. For example, we have correct-by-construction URLs; it is
--   guaranteed that the user does not send the request body when using
--   methods like GET or OPTIONS, and the amount of implicit assumptions is
--   minimized by making the user specify their intentions in an explicit
--   form. For example, it's not possible to avoid specifying the body or
--   the method of a request. Authentication methods that assume HTTPS
--   force the user to use HTTPS at the type level.
--   
--   “Expandable” refers to the ability to create new components without
--   having to resort to hacking. For example, it's possible to define your
--   own HTTP methods, create new ways to construct the body of a request,
--   create new authorization options, perform a request in a different
--   way, and create your own methods to parse a response.
--   
--   <h3>Using with other libraries</h3>
--   
--   <ul>
--   <li>You won't need the low-level interface of <tt>http-client</tt>
--   most of the time, but when you do, it's better to do a qualified
--   import, because <tt>http-client</tt> has naming conflicts with
--   <tt>req</tt>.</li>
--   <li>For streaming of large request bodies see the companion package
--   <tt>req-conduit</tt>:
--   <a>https://hackage.haskell.org/package/req-conduit</a>.</li>
--   </ul>
--   
--   <h3>Lightweight, no risk solution</h3>
--   
--   The library uses the following mature packages under the hood to
--   guarantee you the best experience:
--   
--   <ul>
--   <li><a>https://hackage.haskell.org/package/http-client</a>—low level
--   HTTP client used everywhere in Haskell.</li>
--   <li><a>https://hackage.haskell.org/package/http-client-tls</a>—TLS
--   (HTTPS) support for <tt>http-client</tt>.</li>
--   </ul>
--   
--   It's important to note that since we leverage well-known libraries
--   that the whole Haskell ecosystem uses, there is no risk in using
--   <tt>req</tt>. The machinery for performing requests is the same as
--   with <tt>http-conduit</tt> and <tt>wreq</tt>. The only difference is
--   the API.
module Network.HTTP.Req

-- | Make an HTTP request. The function takes 5 arguments, 4 of which
--   specify required parameters and the final <a>Option</a> argument is a
--   collection of optional parameters.
--   
--   Let's go through all the arguments first: <tt>req method url body
--   response options</tt>.
--   
--   <tt>method</tt> is an HTTP method such as <a>GET</a> or <a>POST</a>.
--   The documentation has a dedicated section about HTTP methods below.
--   
--   <tt>url</tt> is a <a>Url</a> that describes location of resource you
--   want to interact with.
--   
--   <tt>body</tt> is a body option such as <a>NoReqBody</a> or
--   <a>ReqBodyJson</a>. The tutorial has a section about HTTP bodies, but
--   usage is very straightforward and should be clear from the examples.
--   
--   <tt>response</tt> is a type hint how to make and interpret response of
--   an HTTP request. Out-of-the-box it can be the following:
--   
--   <ul>
--   <li><a>ignoreResponse</a></li>
--   <li><a>jsonResponse</a></li>
--   <li><a>bsResponse</a> (to get a strict <a>ByteString</a>)</li>
--   <li><a>lbsResponse</a> (to get a lazy <a>ByteString</a>)</li>
--   </ul>
--   
--   Finally, <tt>options</tt> is a <a>Monoid</a> that holds a composite
--   <a>Option</a> for all other optional settings like query parameters,
--   headers, non-standard port number, etc. There are quite a few things
--   you can put there, see the corresponding section in the documentation.
--   If you don't need anything at all, pass <a>mempty</a>.
--   
--   <b>Note</b> that if you use <a>req</a> to do all your requests,
--   connection sharing and reuse is done for you automatically.
--   
--   See the examples below to get on the speed quickly.
--   
--   <h4><b>Examples</b></h4>
--   
--   First, this is a piece of boilerplate that should be in place before
--   you try the examples:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric     #-}
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   module Main (main) where
--   
--   import Control.Monad
--   import Control.Monad.IO.Class
--   import Data.Aeson
--   import Data.Maybe (fromJust)
--   import Data.Monoid ((&lt;&gt;))
--   import Data.Text (Text)
--   import GHC.Generics
--   import Network.HTTP.Req
--   import qualified Data.ByteString.Char8 as B
--   import qualified Text.URI as URI
--   </pre>
--   
--   We will be making requests against the <a>https://httpbin.org</a>
--   service.
--   
--   Make a GET request, grab 5 random bytes:
--   
--   <pre>
--   main :: IO ()
--   main = runReq defaultHttpConfig $ do
--     let n :: Int
--         n = 5
--     bs &lt;- req GET (https "httpbin.org" /: "bytes" /~ n) NoReqBody bsResponse mempty
--     liftIO $ B.putStrLn (responseBody bs)
--   </pre>
--   
--   The same, but now we use a query parameter named <tt>"seed"</tt> to
--   control seed of the generator:
--   
--   <pre>
--   main :: IO ()
--   main = runReq defaultHttpConfig $ do
--     let n, seed :: Int
--         n    = 5
--         seed = 100
--     bs &lt;- req GET (https "httpbin.org" /: "bytes" /~ n) NoReqBody bsResponse $
--       "seed" =: seed
--     liftIO $ B.putStrLn (responseBody bs)
--   </pre>
--   
--   POST JSON data and get some info about the POST request:
--   
--   <pre>
--   data MyData = MyData
--     { size  :: Int
--     , color :: Text
--     } deriving (Show, Generic)
--   
--   instance ToJSON MyData
--   instance FromJSON MyData
--   
--   main :: IO ()
--   main = runReq defaultHttpConfig $ do
--     let myData = MyData
--           { size  = 6
--           , color = "Green" }
--     v &lt;- req POST (https "httpbin.org" /: "post") (ReqBodyJson myData) jsonResponse mempty
--     liftIO $ print (responseBody v :: Value)
--   </pre>
--   
--   Sending URL-encoded body:
--   
--   <pre>
--   main :: IO ()
--   main = runReq defaultHttpConfig $ do
--     let params =
--           "foo" =: ("bar" :: Text) &lt;&gt;
--           queryFlag "baz"
--     response &lt;- req POST (https "httpbin.org" /: "post") (ReqBodyUrlEnc params) jsonResponse mempty
--     liftIO $ print (responseBody response :: Value)
--   </pre>
--   
--   Using various optional parameters and URL that is not known in
--   advance:
--   
--   <pre>
--   main :: IO ()
--   main = runReq defaultHttpConfig $ do
--     -- This is an example of what to do when URL is given dynamically. Of
--     -- course in a real application you may not want to use 'fromJust'.
--     uri &lt;- URI.mkURI "https://httpbin.org/get?foo=bar"
--     let (url, options) = fromJust (useHttpsURI uri)
--     response &lt;- req GET url NoReqBody jsonResponse $
--       "from" =: (15 :: Int)           &lt;&gt;
--       "to"   =: (67 :: Int)           &lt;&gt;
--       basicAuth "username" "password" &lt;&gt;
--       options                         &lt;&gt; -- contains the ?foo=bar part
--       port 443 -- here you can put any port of course
--     liftIO $ print (responseBody response :: Value)
--   </pre>
req :: (MonadHttp m, HttpMethod method, HttpBody body, HttpResponse response, HttpBodyAllowed (AllowsBody method) (ProvidesBody body)) => method -> Url scheme -> body -> Proxy response -> Option scheme -> m response

-- | A version of <a>req</a> that does not use one of the predefined
--   instances of <a>HttpResponse</a> but instead allows the user to
--   consume <tt><a>Response</a> <a>BodyReader</a></tt> manually, in a
--   custom way.
reqBr :: (MonadHttp m, HttpMethod method, HttpBody body, HttpBodyAllowed (AllowsBody method) (ProvidesBody body)) => method -> Url scheme -> body -> Option scheme -> (Response BodyReader -> IO a) -> m a

-- | A version of <a>req</a> that takes a callback to modify the
--   <a>Request</a>, but otherwise performs the request identically.
reqCb :: (MonadHttp m, HttpMethod method, HttpBody body, HttpResponse response, HttpBodyAllowed (AllowsBody method) (ProvidesBody body)) => method -> Url scheme -> body -> Proxy response -> Option scheme -> (Request -> m Request) -> m response

-- | Mostly like <a>req</a> with respect to its arguments, but accepts a
--   callback that allows to perform a request in arbitrary fashion.
--   
--   This function <i>does not</i> perform handling/wrapping exceptions,
--   checking response (with <a>httpConfigCheckResponse</a>), and retrying.
--   It only prepares <a>Request</a> and allows you to use it.
req' :: forall m method body scheme a. (MonadHttp m, HttpMethod method, HttpBody body, HttpBodyAllowed (AllowsBody method) (ProvidesBody body)) => method -> Url scheme -> body -> Option scheme -> (Request -> Manager -> m a) -> m a

-- | Perform an action using the global implicit <a>Manager</a> that the
--   rest of the library uses. This allows to reuse connections that the
--   <a>Manager</a> controls.
withReqManager :: MonadIO m => (Manager -> m a) -> m a

-- | A type class for monads that support performing HTTP requests.
--   Typically, you only need to define the <a>handleHttpException</a>
--   method unless you want to tweak <a>HttpConfig</a>.
class (MonadIO m) => MonadHttp m

-- | This method describes how to deal with <a>HttpException</a> that was
--   caught by the library. One option is to re-throw it if you are OK with
--   exceptions, but if you prefer working with something like
--   <a>MonadError</a>, this is the right place to pass it to
--   <a>throwError</a>.
handleHttpException :: MonadHttp m => HttpException -> m a

-- | Return the <a>HttpConfig</a> to be used when performing HTTP requests.
--   Default implementation returns its <tt>def</tt> value, which is
--   described in the documentation for the type. Common usage pattern with
--   manually defined <a>getHttpConfig</a> is to return some hard-coded
--   value, or a value extracted from <a>MonadReader</a> if a more flexible
--   approach to configuration is desirable.
getHttpConfig :: MonadHttp m => m HttpConfig

-- | <a>HttpConfig</a> contains settings to be used when making HTTP
--   requests.
data HttpConfig
HttpConfig :: Maybe Proxy -> Int -> Maybe Manager -> (forall b. Request -> Response b -> ByteString -> Maybe HttpExceptionContent) -> RetryPolicyM IO -> (forall b. RetryStatus -> Response b -> Bool) -> (RetryStatus -> SomeException -> Bool) -> (forall a. Num a => a) -> HttpConfig

-- | Proxy to use. By default values of <tt>HTTP_PROXY</tt> and
--   <tt>HTTPS_PROXY</tt> environment variables are respected, this setting
--   overwrites them. Default value: <a>Nothing</a>.
[httpConfigProxy] :: HttpConfig -> Maybe Proxy

-- | How many redirects to follow when getting a resource. Default value:
--   10.
[httpConfigRedirectCount] :: HttpConfig -> Int

-- | Alternative <a>Manager</a> to use. <a>Nothing</a> (default value)
--   means that the default implicit manager will be used (that's what you
--   want in 99% of cases).
[httpConfigAltManager] :: HttpConfig -> Maybe Manager

-- | Function to check the response immediately after receiving the status
--   and headers, before streaming of response body. The third argument is
--   the beginning of response body (typically first 1024 bytes). This is
--   used for throwing exceptions on non-success status codes by default
--   (set to <tt>\_ _ _ -&gt; Nothing</tt> if this behavior is not
--   desirable).
--   
--   When the value this function returns is <a>Nothing</a>, nothing will
--   happen. When it there is <a>HttpExceptionContent</a> inside
--   <a>Just</a>, it will be thrown.
--   
--   Throwing is better then just returning a request with non-2xx status
--   code because in that case something is wrong and we need a way to
--   short-cut execution (also remember that Req retries automatically on
--   request timeouts and such, so when your request fails, it's certainly
--   something exceptional). The thrown exception is caught by the library
--   though and is available in <a>handleHttpException</a>.
--   
--   <b>Note</b>: signature of this function was changed in the version
--   <i>1.0.0</i>.
[httpConfigCheckResponse] :: HttpConfig -> forall b. Request -> Response b -> ByteString -> Maybe HttpExceptionContent

-- | The retry policy to use for request retrying. By default <tt>def</tt>
--   is used (see <a>RetryPolicyM</a>).
--   
--   <b>Note</b>: signature of this function was changed to disallow
--   <a>IO</a> in version <i>1.0.0</i> and then changed back to its current
--   form in <i>3.1.0</i>.
[httpConfigRetryPolicy] :: HttpConfig -> RetryPolicyM IO

-- | The function is used to decide whether to retry a request. <a>True</a>
--   means that the request should be retried.
--   
--   <b>Note</b>: signature of this function was changed in the version
--   <i>1.0.0</i>.
[httpConfigRetryJudge] :: HttpConfig -> forall b. RetryStatus -> Response b -> Bool

-- | Similar to <a>httpConfigRetryJudge</a>, but is used to decide when to
--   retry requests that resulted in an exception. By default it retries on
--   response timeout and connection timeout (changed in version
--   <i>3.8.0</i>).
[httpConfigRetryJudgeException] :: HttpConfig -> RetryStatus -> SomeException -> Bool

-- | Max length of preview fragment of response body.
[httpConfigBodyPreviewLength] :: HttpConfig -> forall a. Num a => a

-- | The default value of <a>HttpConfig</a>.
defaultHttpConfig :: HttpConfig

-- | A monad that allows us to run <a>req</a> in any <a>IO</a>-enabled
--   monad without having to define new instances.
data Req a

-- | Run a computation in the <a>Req</a> monad with the given
--   <a>HttpConfig</a>. In the case of an exceptional situation an
--   <a>HttpException</a> will be thrown.
runReq :: MonadIO m => HttpConfig -> Req a -> m a

-- | <a>GET</a> method.
data GET
GET :: GET

-- | <a>POST</a> method.
data POST
POST :: POST

-- | <a>HEAD</a> method.
data HEAD
HEAD :: HEAD

-- | <a>PUT</a> method.
data PUT
PUT :: PUT

-- | <a>DELETE</a> method. RFC 7231 allows a payload in DELETE but without
--   semantics.
--   
--   <b>Note</b>: before version <i>3.4.0</i> this method did not allow
--   request bodies.
data DELETE
DELETE :: DELETE

-- | <a>TRACE</a> method.
data TRACE
TRACE :: TRACE

-- | <a>CONNECT</a> method.
data CONNECT
CONNECT :: CONNECT

-- | <a>OPTIONS</a> method.
data OPTIONS
OPTIONS :: OPTIONS

-- | <a>PATCH</a> method.
data PATCH
PATCH :: PATCH

-- | A type class for types that can be used as an HTTP method. To define a
--   non-standard method, follow this example that defines <tt>COPY</tt>:
--   
--   <pre>
--   data COPY = COPY
--   
--   instance HttpMethod COPY where
--     type AllowsBody COPY = 'CanHaveBody
--     httpMethodName Proxy = "COPY"
--   </pre>
class HttpMethod a where {
    
    -- | Type function <a>AllowsBody</a> returns a type of kind
    --   <a>CanHaveBody</a> which tells the rest of the library whether the
    --   method can have body or not. We use the special type
    --   <a>CanHaveBody</a> lifted to the kind level instead of <a>Bool</a> to
    --   get more user-friendly compiler messages.
    type AllowsBody a :: CanHaveBody;
}

-- | Return name of the method as a <a>ByteString</a>.
httpMethodName :: HttpMethod a => Proxy a -> ByteString

-- | Request's <a>Url</a>. Start constructing your <a>Url</a> with
--   <a>http</a> or <a>https</a> specifying the scheme and host at the same
--   time. Then use the <tt>(<a>/~</a>)</tt> and <tt>(<a>/:</a>)</tt>
--   operators to grow the path one piece at a time. Every single piece of
--   path will be url(percent)-encoded, so using <tt>(<a>/~</a>)</tt> and
--   <tt>(<a>/:</a>)</tt> is the only way to have forward slashes between
--   path segments. This approach makes working with dynamic path segments
--   easy and safe. See examples below how to represent various <a>Url</a>s
--   (make sure the <tt>OverloadedStrings</tt> language extension is
--   enabled).
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   http "httpbin.org"
--   -- http://httpbin.org
--   </pre>
--   
--   <pre>
--   https "httpbin.org"
--   -- https://httpbin.org
--   </pre>
--   
--   <pre>
--   https "httpbin.org" /: "encoding" /: "utf8"
--   -- https://httpbin.org/encoding/utf8
--   </pre>
--   
--   <pre>
--   https "httpbin.org" /: "foo" /: "bar/baz"
--   -- https://httpbin.org/foo/bar%2Fbaz
--   </pre>
--   
--   <pre>
--   https "httpbin.org" /: "bytes" /~ (10 :: Int)
--   -- https://httpbin.org/bytes/10
--   </pre>
--   
--   <pre>
--   https "юникод.рф"
--   -- https://%D1%8E%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4.%D1%80%D1%84
--   </pre>
data Url (scheme :: Scheme)

-- | Given host name, produce a <a>Url</a> which has “http” as its scheme
--   and empty path. This also sets port to <tt>80</tt>.
http :: Text -> Url 'Http

-- | Given host name, produce a <a>Url</a> which has “https” as its scheme
--   and empty path. This also sets port to <tt>443</tt>.
https :: Text -> Url 'Https

-- | Grow a given <a>Url</a> appending a single path segment to it. Note
--   that the path segment can be of any type that is an instance of
--   <a>ToHttpApiData</a>.
(/~) :: ToHttpApiData a => Url scheme -> a -> Url scheme
infixl 5 /~

-- | A type-constrained version of <tt>(<a>/~</a>)</tt> to remove ambiguity
--   in the cases when next URL piece is a <a>Text</a> literal.
(/:) :: Url scheme -> Text -> Url scheme
infixl 5 /:

-- | The <a>useHttpURI</a> function provides an alternative method to get
--   <a>Url</a> (possibly with some <a>Option</a>s) from a <a>URI</a>. This
--   is useful when you are given a URL to query dynamically and don't know
--   it beforehand.
--   
--   This function expects the scheme to be “http” and host to be present.
useHttpURI :: URI -> Maybe (Url 'Http, Option scheme)

-- | Just like <a>useHttpURI</a>, but expects the “https” scheme.
useHttpsURI :: URI -> Maybe (Url 'Https, Option scheme)

-- | A combination of <a>useHttpURI</a> and <a>useHttpsURI</a> for cases
--   when scheme is not known in advance.
useURI :: URI -> Maybe (Either (Url 'Http, Option scheme0) (Url 'Https, Option scheme1))

-- | A quasiquoter to build an <a>Url</a> and <a>Option</a> tuple. The type
--   of the generated expression is <tt>(<a>Url</a> scheme0, <a>Option</a>
--   scheme1)</tt> with <tt>scheme0</tt> being either <a>Http</a> or
--   <a>Https</a> depending on the input.
urlQ :: QuasiQuoter

-- | Render a <a>Url</a> as <a>ErrorMessage</a>.
renderUrl :: Url scheme -> Text

-- | This data type represents empty body of an HTTP request. This is the
--   data type to use with <a>HttpMethod</a>s that cannot have a body, as
--   it's the only type for which <a>ProvidesBody</a> returns
--   <a>NoBody</a>.
--   
--   Using of this body option does not set the <tt>Content-Type</tt>
--   header.
data NoReqBody
NoReqBody :: NoReqBody

-- | This body option allows us to use a JSON object as the request
--   body—probably the most popular format right now. Just wrap a data type
--   that is an instance of <a>ToJSON</a> type class and you are done: it
--   will be converted to JSON and inserted as request body.
--   
--   This body option sets the <tt>Content-Type</tt> header to
--   <tt>"application/json; charset=utf-8"</tt> value.
newtype ReqBodyJson a
ReqBodyJson :: a -> ReqBodyJson a

-- | This body option streams request body from a file. It is expected that
--   the file size does not change during streaming.
--   
--   Using of this body option does not set the <tt>Content-Type</tt>
--   header.
newtype ReqBodyFile
ReqBodyFile :: FilePath -> ReqBodyFile

-- | HTTP request body represented by a strict <a>ByteString</a>.
--   
--   Using of this body option does not set the <tt>Content-Type</tt>
--   header.
newtype ReqBodyBs
ReqBodyBs :: ByteString -> ReqBodyBs

-- | HTTP request body represented by a lazy <a>ByteString</a>.
--   
--   Using of this body option does not set the <tt>Content-Type</tt>
--   header.
newtype ReqBodyLbs
ReqBodyLbs :: ByteString -> ReqBodyLbs

-- | URL-encoded body. This can hold a collection of parameters which are
--   encoded similarly to query parameters at the end of query string, with
--   the only difference that they are stored in request body. The
--   similarity is reflected in the API as well, as you can use the same
--   combinators you would use to add query parameters:
--   <tt>(<a>=:</a>)</tt> and <a>queryFlag</a>.
--   
--   This body option sets the <tt>Content-Type</tt> header to
--   <tt>"application/x-www-form-urlencoded"</tt> value.
newtype ReqBodyUrlEnc
ReqBodyUrlEnc :: FormUrlEncodedParam -> ReqBodyUrlEnc

-- | An opaque monoidal value that allows to collect URL-encoded parameters
--   to be wrapped in <a>ReqBodyUrlEnc</a>.
data FormUrlEncodedParam

-- | Multipart form data. Please consult the
--   <a>Network.HTTP.Client.MultipartFormData</a> module for how to
--   construct parts, then use <a>reqBodyMultipart</a> to create actual
--   request body from the parts. <a>reqBodyMultipart</a> is the only way
--   to get a value of the type <a>ReqBodyMultipart</a>, as its constructor
--   is not exported on purpose.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   import Control.Monad.IO.Class
--   import Data.Default.Class
--   import Network.HTTP.Req
--   import qualified Network.HTTP.Client.MultipartFormData as LM
--   
--   main :: IO ()
--   main = runReq def $ do
--     body &lt;-
--       reqBodyMultipart
--         [ LM.partBS "title" "My Image"
--         , LM.partFileSource "file1" "/tmp/image.jpg"
--         ]
--     response &lt;-
--       req POST (http "example.com" /: "post")
--         body
--         bsResponse
--         mempty
--     liftIO $ print (responseBody response)
--   </pre>
data ReqBodyMultipart

-- | Create <a>ReqBodyMultipart</a> request body from a collection of
--   <a>Part</a>s.
reqBodyMultipart :: MonadIO m => [Part] -> m ReqBodyMultipart

-- | A type class for things that can be interpreted as an HTTP
--   <a>RequestBody</a>.
class HttpBody body

-- | How to get actual <a>RequestBody</a>.
getRequestBody :: HttpBody body => body -> RequestBody

-- | This method allows us to optionally specify the value of
--   <tt>Content-Type</tt> header that should be used with particular body
--   option. By default it returns <a>Nothing</a> and so
--   <tt>Content-Type</tt> is not set.
getRequestContentType :: HttpBody body => body -> Maybe ByteString

-- | The type function recognizes <a>NoReqBody</a> as having <a>NoBody</a>,
--   while any other body option <a>CanHaveBody</a>. This forces the user
--   to use <a>NoReqBody</a> with <a>GET</a> method and other methods that
--   should not have body.
type family ProvidesBody body :: CanHaveBody

-- | This type function allows any HTTP body if method says it
--   <a>CanHaveBody</a>. When the method says it should have <a>NoBody</a>,
--   the only body option to use is <a>NoReqBody</a>.
type family HttpBodyAllowed (allowsBody :: CanHaveBody) (providesBody :: CanHaveBody) :: Constraint

-- | The opaque <a>Option</a> type is a <a>Monoid</a> you can use to pack
--   collection of optional parameters like query parameters and headers.
--   See sections below to learn which <a>Option</a> primitives are
--   available.
data Option (scheme :: Scheme)

-- | This operator builds a query parameter that will be included in URL of
--   your request after the question sign <tt>?</tt>. This is the same
--   syntax you use with form URL encoded request bodies.
--   
--   This operator is defined in terms of <a>queryParam</a>:
--   
--   <pre>
--   name =: value = queryParam name (pure value)
--   </pre>
(=:) :: (QueryParam param, ToHttpApiData a) => Text -> a -> param
infix 7 =:

-- | Construct a flag, that is, a valueless query parameter. For example,
--   in the following URL <tt>"a"</tt> is a flag, while <tt>"b"</tt> is a
--   query parameter with a value:
--   
--   <pre>
--   https://httpbin.org/foo/bar?a&amp;b=10
--   </pre>
--   
--   This operator is defined in terms of <a>queryParam</a>:
--   
--   <pre>
--   queryFlag name = queryParam name (Nothing :: Maybe ())
--   </pre>
queryFlag :: QueryParam param => Text -> param

-- | Construct query parameters from a <a>ToForm</a> instance. This
--   function produces the same query params as
--   <a>urlEncodeAsFormStable</a>.
--   
--   Note that <a>Form</a> doesn't have the concept of parameters with the
--   empty value (i.e. what you can get by <tt>key =: ""</tt>). If the
--   value is empty, it will be encoded as a valueless parameter (i.e. what
--   you can get by <tt>queryFlag key</tt>).
formToQuery :: (QueryParam param, Monoid param, ToForm f) => f -> param

-- | A type class for query-parameter-like things. The reason to have an
--   overloaded <a>queryParam</a> is to be able to use it as an
--   <a>Option</a> and as a <a>FormUrlEncodedParam</a> when constructing
--   form URL encoded request bodies. Having the same syntax for these
--   cases seems natural and user-friendly.
class QueryParam param

-- | Create a query parameter with given name and value. If value is
--   <a>Nothing</a>, it won't be included at all (i.e. you create a flag
--   this way). It's recommended to use <tt>(<a>=:</a>)</tt> and
--   <a>queryFlag</a> instead of this method, because they are easier to
--   read.
queryParam :: (QueryParam param, ToHttpApiData a) => Text -> Maybe a -> param

-- | Get the query parameter names and values set by <a>queryParam</a>.
queryParamToList :: QueryParam param => param -> [(Text, Maybe Text)]

-- | Create an <a>Option</a> that adds a header. Note that if you
--   <a>mappend</a> two headers with the same names the leftmost header
--   will win. This means, in particular, that you cannot create a request
--   with several headers of the same name.
header :: ByteString -> ByteString -> Option scheme

-- | Attach a header with given name and content to a <a>Request</a>.
attachHeader :: ByteString -> ByteString -> Request -> Request

-- | Same as <a>header</a>, but with redacted values on print.
headerRedacted :: ByteString -> ByteString -> Option scheme

-- | Use the given <a>CookieJar</a>. A <a>CookieJar</a> can be obtained
--   from a <a>Response</a> record.
cookieJar :: CookieJar -> Option scheme

-- | The <a>Option</a> adds basic authentication.
--   
--   See also:
--   <a>https://en.wikipedia.org/wiki/Basic_access_authentication</a>.
basicAuth :: ByteString -> ByteString -> Option 'Https

-- | An alternative to <a>basicAuth</a> which works for any scheme. Note
--   that using basic access authentication without SSL/TLS is vulnerable
--   to attacks. Use <a>basicAuth</a> instead unless you know what you are
--   doing.
basicAuthUnsafe :: ByteString -> ByteString -> Option scheme

-- | The <a>Option</a> set basic proxy authentication header.
basicProxyAuth :: ByteString -> ByteString -> Option scheme

-- | The <a>Option</a> adds OAuth1 authentication.
oAuth1 :: ByteString -> ByteString -> ByteString -> ByteString -> Option scheme

-- | The <a>Option</a> adds an OAuth2 bearer token. This is treated by many
--   services as the equivalent of a username and password.
--   
--   The <a>Option</a> is defined as:
--   
--   <pre>
--   oAuth2Bearer token = header "Authorization" ("Bearer " &lt;&gt; token)
--   </pre>
--   
--   See also: <a>https://en.wikipedia.org/wiki/OAuth</a>.
oAuth2Bearer :: ByteString -> Option 'Https

-- | The <a>Option</a> adds a not-quite-standard OAuth2 bearer token (that
--   seems to be used only by GitHub). This will be treated by whatever
--   services accept it as the equivalent of a username and password.
--   
--   The <a>Option</a> is defined as:
--   
--   <pre>
--   oAuth2Token token = header "Authorization" ("token" &lt;&gt; token)
--   </pre>
--   
--   See also:
--   <a>https://developer.github.com/v3/oauth#3-use-the-access-token-to-access-the-api</a>.
oAuth2Token :: ByteString -> Option 'Https

-- | A helper to create custom authentication <a>Option</a>s. The given
--   <a>IO</a>-enabled request transformation is applied after all other
--   modifications when constructing a request. Use wisely.
customAuth :: (Request -> IO Request) -> Option scheme

-- | Specify the port to connect to explicitly. Normally, <a>Url</a> you
--   use determines the default port: <tt>80</tt> for HTTP and <tt>443</tt>
--   for HTTPS. This <a>Option</a> allows us to choose an arbitrary port
--   overwriting the defaults.
port :: Int -> Option scheme

-- | This <a>Option</a> controls whether gzipped data should be
--   decompressed on the fly. By default everything except for
--   <tt>"application/x-tar"</tt> is decompressed, i.e. we have:
--   
--   <pre>
--   decompress (/= "application/x-tar")
--   </pre>
--   
--   You can also choose to decompress everything like this:
--   
--   <pre>
--   decompress (const True)
--   </pre>
decompress :: (ByteString -> Bool) -> Option scheme

-- | Specify the number of microseconds to wait for response. The default
--   value is 30 seconds (defined in <a>ManagerSettings</a> of connection
--   <a>Manager</a>).
responseTimeout :: Int -> Option scheme

-- | HTTP version to send to the server, the default is HTTP 1.1.
httpVersion :: Int -> Int -> Option scheme

-- | Make a request and ignore the body of the response.
data IgnoreResponse

-- | Use this as the fourth argument of <a>req</a> to specify that you want
--   it to ignore the response body.
ignoreResponse :: Proxy IgnoreResponse

-- | Make a request and interpret the body of the response as JSON. The
--   <a>handleHttpException</a> method of <a>MonadHttp</a> instance
--   corresponding to monad in which you use <a>req</a> will determine what
--   to do in the case when parsing fails (the <a>JsonHttpException</a>
--   constructor will be used).
data JsonResponse a

-- | Use this as the fourth argument of <a>req</a> to specify that you want
--   it to return the <a>JsonResponse</a> interpretation.
jsonResponse :: Proxy (JsonResponse a)

-- | Make a request and interpret the body of the response as a strict
--   <a>ByteString</a>.
data BsResponse

-- | Use this as the fourth argument of <a>req</a> to specify that you want
--   to interpret the response body as a strict <a>ByteString</a>.
bsResponse :: Proxy BsResponse

-- | Make a request and interpret the body of the response as a lazy
--   <a>ByteString</a>.
data LbsResponse

-- | Use this as the fourth argument of <a>req</a> to specify that you want
--   to interpret the response body as a lazy <a>ByteString</a>.
lbsResponse :: Proxy LbsResponse

-- | Get the response body.
responseBody :: HttpResponse response => response -> HttpResponseBody response

-- | Get the response status code.
responseStatusCode :: HttpResponse response => response -> Int

-- | Get the response status message.
responseStatusMessage :: HttpResponse response => response -> ByteString

-- | Lookup a particular header from a response.
responseHeader :: HttpResponse response => response -> ByteString -> Maybe ByteString

-- | Get the response <a>CookieJar</a>.
responseCookieJar :: HttpResponse response => response -> CookieJar

-- | A type class for response interpretations. It allows us to describe
--   how to consume the response from a <tt><a>Response</a>
--   <a>BodyReader</a></tt> and produce the final result that is to be
--   returned to the user.
class HttpResponse response where {
    
    -- | The associated type is the type of body that can be extracted from an
    --   instance of <a>HttpResponse</a>.
    type HttpResponseBody response :: Type;
}

-- | The method describes how to get the underlying <a>Response</a> record.
toVanillaResponse :: HttpResponse response => response -> Response (HttpResponseBody response)

-- | This method describes how to consume response body and, more
--   generally, obtain <tt>response</tt> value from <tt><a>Response</a>
--   <a>BodyReader</a></tt>.
--   
--   <b>Note</b>: <a>BodyReader</a> is nothing but <tt><a>IO</a>
--   <a>ByteString</a></tt>. You should call this action repeatedly until
--   it yields the empty <a>ByteString</a>. In that case streaming of
--   response is finished (which apparently leads to closing of the
--   connection, so don't call the reader after it has returned the empty
--   <a>ByteString</a> once) and you can concatenate the chunks to obtain
--   the final result. (Of course you could as well stream the contents to
--   a file or do whatever you want.)
--   
--   <b>Note</b>: signature of this function was changed in the version
--   <i>1.0.0</i>.
getHttpResponse :: HttpResponse response => Response BodyReader -> IO response

-- | The value of <tt>"Accept"</tt> header. This is useful, for example, if
--   a website supports both <tt>XML</tt> and <tt>JSON</tt> responses, and
--   decides what to reply with based on what <tt>Accept</tt> headers you
--   have sent.
--   
--   <b>Note</b>: manually specified <tt>Options</tt> that set the
--   <tt>"Accept"</tt> header will take precedence.
acceptHeader :: HttpResponse response => Proxy response -> Maybe ByteString

-- | Exceptions that this library throws.
data HttpException

-- | A wrapper with an <a>HttpException</a> from <a>Network.HTTP.Client</a>
VanillaHttpException :: HttpException -> HttpException

-- | A wrapper with Aeson-produced <a>String</a> describing why decoding
--   failed
JsonHttpException :: String -> HttpException

-- | Return <a>Just</a> if the given <a>HttpException</a> is wrapping a
--   http-client's <a>StatusCodeException</a>. Otherwise, return
--   <a>Nothing</a>.
isStatusCodeException :: HttpException -> Maybe (Response ())

-- | A simple type isomorphic to <a>Bool</a> that we only have for better
--   error messages. We use it as a kind and its data constructors as
--   type-level tags.
--   
--   See also: <a>HttpMethod</a> and <a>HttpBody</a>.
data CanHaveBody

-- | Indeed can have a body
CanHaveBody :: CanHaveBody

-- | Should not have a body
NoBody :: CanHaveBody

-- | A type-level tag that specifies URL scheme used (and thus if HTTPS is
--   enabled). This is used to force TLS requirement for some
--   authentication <a>Option</a>s.
data Scheme

-- | HTTP
Http :: Scheme

-- | HTTPS
Https :: Scheme
instance Control.Monad.IO.Unlift.MonadUnliftIO Network.HTTP.Req.Req
instance Control.Monad.IO.Class.MonadIO Network.HTTP.Req.Req
instance GHC.Base.Monad Network.HTTP.Req.Req
instance GHC.Base.Applicative Network.HTTP.Req.Req
instance GHC.Base.Functor Network.HTTP.Req.Req
instance GHC.Base.Monoid Network.HTTP.Req.FormUrlEncodedParam
instance GHC.Base.Semigroup Network.HTTP.Req.FormUrlEncodedParam
instance GHC.Show.Show Network.HTTP.Req.IgnoreResponse
instance GHC.Show.Show a => GHC.Show.Show (Network.HTTP.Req.JsonResponse a)
instance GHC.Show.Show Network.HTTP.Req.BsResponse
instance GHC.Show.Show Network.HTTP.Req.LbsResponse
instance GHC.Generics.Generic Network.HTTP.Req.HttpException
instance GHC.Show.Show Network.HTTP.Req.HttpException
instance Language.Haskell.TH.Syntax.Lift Network.HTTP.Req.Scheme
instance GHC.Generics.Generic Network.HTTP.Req.Scheme
instance Data.Data.Data Network.HTTP.Req.Scheme
instance GHC.Show.Show Network.HTTP.Req.Scheme
instance GHC.Classes.Ord Network.HTTP.Req.Scheme
instance GHC.Classes.Eq Network.HTTP.Req.Scheme
instance GHC.Generics.Generic (Network.HTTP.Req.Url scheme)
instance Data.Typeable.Internal.Typeable scheme => Data.Data.Data (Network.HTTP.Req.Url scheme)
instance GHC.Show.Show (Network.HTTP.Req.Url scheme)
instance GHC.Classes.Ord (Network.HTTP.Req.Url scheme)
instance GHC.Classes.Eq (Network.HTTP.Req.Url scheme)
instance Control.Monad.Catch.MonadThrow Network.HTTP.Req.Req
instance Control.Monad.Catch.MonadCatch Network.HTTP.Req.Req
instance Control.Monad.Catch.MonadMask Network.HTTP.Req.Req
instance Data.Typeable.Internal.Typeable scheme => Language.Haskell.TH.Syntax.Lift (Network.HTTP.Req.Url scheme)
instance Network.HTTP.Req.RequestComponent (Network.HTTP.Req.Url scheme)
instance GHC.Base.Semigroup (Network.HTTP.Req.Option scheme)
instance GHC.Base.Monoid (Network.HTTP.Req.Option scheme)
instance Web.Internal.FormUrlEncoded.FromForm (Network.HTTP.Req.Option scheme)
instance Network.HTTP.Req.RequestComponent (Network.HTTP.Req.Option scheme)
instance Network.HTTP.Req.QueryParam (Network.HTTP.Req.Option scheme)
instance Network.HTTP.Req.HttpMethod Network.HTTP.Req.GET
instance Network.HTTP.Req.HttpMethod Network.HTTP.Req.POST
instance Network.HTTP.Req.HttpMethod Network.HTTP.Req.HEAD
instance Network.HTTP.Req.HttpMethod Network.HTTP.Req.PUT
instance Network.HTTP.Req.HttpMethod Network.HTTP.Req.DELETE
instance Network.HTTP.Req.HttpMethod Network.HTTP.Req.TRACE
instance Network.HTTP.Req.HttpMethod Network.HTTP.Req.CONNECT
instance Network.HTTP.Req.HttpMethod Network.HTTP.Req.OPTIONS
instance Network.HTTP.Req.HttpMethod Network.HTTP.Req.PATCH
instance Network.HTTP.Req.HttpMethod method => Network.HTTP.Req.RequestComponent (Network.HTTP.Req.Tagged "method" method)
instance Network.HTTP.Req.MonadHttp Network.HTTP.Req.Req
instance (Network.HTTP.Req.MonadHttp m, GHC.Base.Monoid w) => Network.HTTP.Req.MonadHttp (Control.Monad.Trans.Accum.AccumT w m)
instance Network.HTTP.Req.MonadHttp m => Network.HTTP.Req.MonadHttp (Control.Monad.Trans.Cont.ContT r m)
instance Network.HTTP.Req.MonadHttp m => Network.HTTP.Req.MonadHttp (Control.Monad.Trans.Except.ExceptT e m)
instance Network.HTTP.Req.MonadHttp m => Network.HTTP.Req.MonadHttp (Control.Monad.Trans.Identity.IdentityT m)
instance Network.HTTP.Req.MonadHttp m => Network.HTTP.Req.MonadHttp (Control.Monad.Trans.Maybe.MaybeT m)
instance Network.HTTP.Req.MonadHttp m => Network.HTTP.Req.MonadHttp (Control.Monad.Trans.Reader.ReaderT r m)
instance (Network.HTTP.Req.MonadHttp m, GHC.Base.Monoid w) => Network.HTTP.Req.MonadHttp (Control.Monad.Trans.RWS.CPS.RWST r w s m)
instance (Network.HTTP.Req.MonadHttp m, GHC.Base.Monoid w) => Network.HTTP.Req.MonadHttp (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Network.HTTP.Req.MonadHttp m, GHC.Base.Monoid w) => Network.HTTP.Req.MonadHttp (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Network.HTTP.Req.MonadHttp m => Network.HTTP.Req.MonadHttp (Control.Monad.Trans.Select.SelectT r m)
instance Network.HTTP.Req.MonadHttp m => Network.HTTP.Req.MonadHttp (Control.Monad.Trans.State.Lazy.StateT s m)
instance Network.HTTP.Req.MonadHttp m => Network.HTTP.Req.MonadHttp (Control.Monad.Trans.State.Strict.StateT s m)
instance (Network.HTTP.Req.MonadHttp m, GHC.Base.Monoid w) => Network.HTTP.Req.MonadHttp (Control.Monad.Trans.Writer.CPS.WriterT w m)
instance (Network.HTTP.Req.MonadHttp m, GHC.Base.Monoid w) => Network.HTTP.Req.MonadHttp (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (Network.HTTP.Req.MonadHttp m, GHC.Base.Monoid w) => Network.HTTP.Req.MonadHttp (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Data.Aeson.Types.FromJSON.FromJSON a => Network.HTTP.Req.HttpResponse (Network.HTTP.Req.JsonResponse a)
instance GHC.Exception.Type.Exception Network.HTTP.Req.HttpException
instance Network.HTTP.Req.HttpBody body => Network.HTTP.Req.RequestComponent (Network.HTTP.Req.Tagged "body" body)
instance Network.HTTP.Req.RequestComponent Network.HTTP.Req.HttpConfig
instance Network.HTTP.Req.HttpResponse Network.HTTP.Req.IgnoreResponse
instance Network.HTTP.Req.HttpResponse Network.HTTP.Req.BsResponse
instance Network.HTTP.Req.HttpResponse Network.HTTP.Req.LbsResponse
instance Network.HTTP.Req.HttpResponse (Network.HTTP.Client.Types.Response ())
instance Network.HTTP.Req.QueryParam Network.HTTP.Req.FormUrlEncodedParam
instance Network.HTTP.Req.HttpBody Network.HTTP.Req.NoReqBody
instance Data.Aeson.Types.ToJSON.ToJSON a => Network.HTTP.Req.HttpBody (Network.HTTP.Req.ReqBodyJson a)
instance Network.HTTP.Req.HttpBody Network.HTTP.Req.ReqBodyFile
instance Network.HTTP.Req.HttpBody Network.HTTP.Req.ReqBodyBs
instance Network.HTTP.Req.HttpBody Network.HTTP.Req.ReqBodyLbs
instance Network.HTTP.Req.HttpBody Network.HTTP.Req.ReqBodyUrlEnc
instance Network.HTTP.Req.HttpBody Network.HTTP.Req.ReqBodyMultipart
instance Web.Internal.FormUrlEncoded.FromForm Network.HTTP.Req.FormUrlEncodedParam
instance Control.Monad.Base.MonadBase GHC.Types.IO Network.HTTP.Req.Req
instance Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO Network.HTTP.Req.Req
