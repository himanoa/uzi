<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>RIO.Lens</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">rio-0.1.22.0: A standard library for Haskell</span><ul class="links" id="page-menu"><li><a href="src/RIO.Lens.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>License</th><td>MIT</td></tr><tr><th>Maintainer</th><td>Colin Woodbury &lt;colin@fosskers.ca&gt;</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">RIO.Lens</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Fold</a></li><li><a href="#g:2">Lens</a></li><li><a href="#g:3">Iso</a></li><li><a href="#g:4">Traversal</a></li><li><a href="#g:5">Prism</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Extra utilities from <code>microlens</code>.</p><p>@since: 0.1.16.0</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">type</span> <a href="#t:SimpleFold">SimpleFold</a> s a = <span class="keyword">forall</span> r. <a href="RIO-Prelude-Types.html#t:Monoid" title="RIO.Prelude.Types">Monoid</a> r =&gt; <a href="RIO.html#t:Getting" title="RIO">Getting</a> r s a</li><li class="src short"><a href="#v:toListOf">toListOf</a> :: <a href="RIO.html#t:Getting" title="RIO">Getting</a> (<a href="../base-4.18.2.0/Data-Monoid.html#t:Endo" title="Data.Monoid">Endo</a> [a]) s a -&gt; s -&gt; [a]</li><li class="src short"><a href="#v:has">has</a> :: <a href="RIO.html#t:Getting" title="RIO">Getting</a> <a href="../base-4.18.2.0/Data-Monoid.html#t:Any" title="Data.Monoid">Any</a> s a -&gt; s -&gt; <a href="RIO-Prelude-Types.html#t:Bool" title="RIO.Prelude.Types">Bool</a></li><li class="src short"><a href="#v:_1">_1</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Field1" title="Lens.Micro.Internal">Field1</a> s t a b =&gt; <a href="RIO.html#t:Lens" title="RIO">Lens</a> s t a b</li><li class="src short"><a href="#v:_2">_2</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Field2" title="Lens.Micro.Internal">Field2</a> s t a b =&gt; <a href="RIO.html#t:Lens" title="RIO">Lens</a> s t a b</li><li class="src short"><a href="#v:_3">_3</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Field3" title="Lens.Micro.Internal">Field3</a> s t a b =&gt; <a href="RIO.html#t:Lens" title="RIO">Lens</a> s t a b</li><li class="src short"><a href="#v:_4">_4</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Field4" title="Lens.Micro.Internal">Field4</a> s t a b =&gt; <a href="RIO.html#t:Lens" title="RIO">Lens</a> s t a b</li><li class="src short"><a href="#v:_5">_5</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Field5" title="Lens.Micro.Internal">Field5</a> s t a b =&gt; <a href="RIO.html#t:Lens" title="RIO">Lens</a> s t a b</li><li class="src short"><a href="#v:at">at</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:At" title="Lens.Micro.Internal">At</a> m =&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Index" title="Lens.Micro.Internal">Index</a> m -&gt; <a href="RIO.html#t:Lens-39-" title="RIO">Lens'</a> m (<a href="RIO-Prelude-Types.html#t:Maybe" title="RIO.Prelude.Types">Maybe</a> (<a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:IxValue" title="Lens.Micro.Internal">IxValue</a> m))</li><li class="src short"><a href="#v:lens">lens</a> :: (s -&gt; a) -&gt; (s -&gt; b -&gt; t) -&gt; <a href="RIO.html#t:Lens" title="RIO">Lens</a> s t a b</li><li class="src short"><a href="#v:non">non</a> :: <a href="RIO-Prelude-Types.html#t:Eq" title="RIO.Prelude.Types">Eq</a> a =&gt; a -&gt; <a href="RIO.html#t:Lens-39-" title="RIO">Lens'</a> (<a href="RIO-Prelude-Types.html#t:Maybe" title="RIO.Prelude.Types">Maybe</a> a) a</li><li class="src short"><a href="#v:singular">singular</a> :: <a href="RIO-Prelude-Types.html#t:HasCallStack" title="RIO.Prelude.Types">HasCallStack</a> =&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal" title="Lens.Micro.Type">Traversal</a> s t a a -&gt; <a href="RIO.html#t:Lens" title="RIO">Lens</a> s t a a</li><li class="src short"><a href="#v:failing">failing</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal" title="Lens.Micro.Type">Traversal</a> s t a b -&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal" title="Lens.Micro.Type">Traversal</a> s t a b -&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal" title="Lens.Micro.Type">Traversal</a> s t a b</li><li class="src short"><a href="#v:filtered">filtered</a> :: (a -&gt; <a href="RIO-Prelude-Types.html#t:Bool" title="RIO.Prelude.Types">Bool</a>) -&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal-39-" title="Lens.Micro.Type">Traversal'</a> a a</li><li class="src short"><a href="#v:both">both</a> :: <span class="keyword">forall</span> a b f. <a href="RIO-Prelude-Types.html#t:Applicative" title="RIO.Prelude.Types">Applicative</a> f =&gt; (a -&gt; f b) -&gt; (a, a) -&gt; f (b, b)</li><li class="src short"><a href="#v:traversed">traversed</a> :: <span class="keyword">forall</span> (f :: <a href="../base-4.18.2.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.18.2.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a b. <a href="RIO-Prelude-Types.html#t:Traversable" title="RIO.Prelude.Types">Traversable</a> f =&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal" title="Lens.Micro.Type">Traversal</a> (f a) (f b) a b</li><li class="src short"><a href="#v:each">each</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Each" title="Lens.Micro.Internal">Each</a> s t a b =&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal" title="Lens.Micro.Type">Traversal</a> s t a b</li><li class="src short"><a href="#v:ix">ix</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Ixed" title="Lens.Micro.Internal">Ixed</a> m =&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Index" title="Lens.Micro.Internal">Index</a> m -&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal-39-" title="Lens.Micro.Type">Traversal'</a> m (<a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:IxValue" title="Lens.Micro.Internal">IxValue</a> m)</li><li class="src short"><a href="#v:_head">_head</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Cons" title="Lens.Micro.Internal">Cons</a> s s a a =&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal-39-" title="Lens.Micro.Type">Traversal'</a> s a</li><li class="src short"><a href="#v:_tail">_tail</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Cons" title="Lens.Micro.Internal">Cons</a> s s a a =&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal-39-" title="Lens.Micro.Type">Traversal'</a> s s</li><li class="src short"><a href="#v:_init">_init</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Snoc" title="Lens.Micro.Internal">Snoc</a> s s a a =&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal-39-" title="Lens.Micro.Type">Traversal'</a> s s</li><li class="src short"><a href="#v:_last">_last</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Snoc" title="Lens.Micro.Internal">Snoc</a> s s a a =&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal-39-" title="Lens.Micro.Type">Traversal'</a> s a</li><li class="src short"><a href="#v:_Left">_Left</a> :: <span class="keyword">forall</span> a b a' f. <a href="RIO-Prelude-Types.html#t:Applicative" title="RIO.Prelude.Types">Applicative</a> f =&gt; (a -&gt; f a') -&gt; <a href="RIO-Prelude-Types.html#t:Either" title="RIO.Prelude.Types">Either</a> a b -&gt; f (<a href="RIO-Prelude-Types.html#t:Either" title="RIO.Prelude.Types">Either</a> a' b)</li><li class="src short"><a href="#v:_Right">_Right</a> :: <span class="keyword">forall</span> a b b' f. <a href="RIO-Prelude-Types.html#t:Applicative" title="RIO.Prelude.Types">Applicative</a> f =&gt; (b -&gt; f b') -&gt; <a href="RIO-Prelude-Types.html#t:Either" title="RIO.Prelude.Types">Either</a> a b -&gt; f (<a href="RIO-Prelude-Types.html#t:Either" title="RIO.Prelude.Types">Either</a> a b')</li><li class="src short"><a href="#v:_Just">_Just</a> :: <span class="keyword">forall</span> a a' f. <a href="RIO-Prelude-Types.html#t:Applicative" title="RIO.Prelude.Types">Applicative</a> f =&gt; (a -&gt; f a') -&gt; <a href="RIO-Prelude-Types.html#t:Maybe" title="RIO.Prelude.Types">Maybe</a> a -&gt; f (<a href="RIO-Prelude-Types.html#t:Maybe" title="RIO.Prelude.Types">Maybe</a> a')</li><li class="src short"><a href="#v:_Nothing">_Nothing</a> :: <span class="keyword">forall</span> a f. <a href="RIO-Prelude-Types.html#t:Applicative" title="RIO.Prelude.Types">Applicative</a> f =&gt; (() -&gt; f ()) -&gt; <a href="RIO-Prelude-Types.html#t:Maybe" title="RIO.Prelude.Types">Maybe</a> a -&gt; f (<a href="RIO-Prelude-Types.html#t:Maybe" title="RIO.Prelude.Types">Maybe</a> a)</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Fold</h1></a><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:SimpleFold" class="def">SimpleFold</a> s a = <span class="keyword">forall</span> r. <a href="RIO-Prelude-Types.html#t:Monoid" title="RIO.Prelude.Types">Monoid</a> r =&gt; <a href="RIO.html#t:Getting" title="RIO">Getting</a> r s a <a href="#t:SimpleFold" class="selflink">#</a></p><div class="doc"><p>A <code>SimpleFold s a</code> extracts several <code>a</code>s from <code>s</code>; so, it's pretty much the same thing as <code>(s -&gt; [a])</code>, but you can use it with lens operators.</p><p>The actual <code>Fold</code> from lens is more general:</p><pre>type Fold s a =
  forall f. (Contravariant f, Applicative f) =&gt; (a -&gt; f a) -&gt; s -&gt; f s
</pre><p>There are several functions in lens that accept lens's <code>Fold</code> but won't accept <code><a href="RIO-Lens.html#t:SimpleFold" title="RIO.Lens">SimpleFold</a></code>; I'm aware of
<code><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:takingWhile">takingWhile</a></code>,
<code><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:droppingWhile">droppingWhile</a></code>,
<code><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:backwards">backwards</a></code>,
<code><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:foldByOf">foldByOf</a></code>,
<code><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:foldMapByOf">foldMapByOf</a></code>.
For this reason, try not to export <code><a href="RIO-Lens.html#t:SimpleFold" title="RIO.Lens">SimpleFold</a></code>s if at all possible. <a href="http://hackage.haskell.org/package/microlens-contra">microlens-contra</a> provides a fully lens-compatible <code>Fold</code>.</p><p>Lens users: you can convert a <code><a href="RIO-Lens.html#t:SimpleFold" title="RIO.Lens">SimpleFold</a></code> to <code>Fold</code> by applying <code>folded . toListOf</code> to it.</p></div></div><div class="top"><p class="src"><a id="v:toListOf" class="def">toListOf</a> :: <a href="RIO.html#t:Getting" title="RIO">Getting</a> (<a href="../base-4.18.2.0/Data-Monoid.html#t:Endo" title="Data.Monoid">Endo</a> [a]) s a -&gt; s -&gt; [a] <a href="#v:toListOf" class="selflink">#</a></p><div class="doc"><p><code><a href="RIO-Lens.html#v:toListOf" title="RIO.Lens">toListOf</a></code> is a synonym for (<code><a href="RIO.html#v:-94-.." title="RIO">^..</a></code>).</p></div></div><div class="top"><p class="src"><a id="v:has" class="def">has</a> :: <a href="RIO.html#t:Getting" title="RIO">Getting</a> <a href="../base-4.18.2.0/Data-Monoid.html#t:Any" title="Data.Monoid">Any</a> s a -&gt; s -&gt; <a href="RIO-Prelude-Types.html#t:Bool" title="RIO.Prelude.Types">Bool</a> <a href="#v:has" class="selflink">#</a></p><div class="doc"><p><code><a href="RIO-Lens.html#v:has" title="RIO.Lens">has</a></code> checks whether a getter (any getter, including lenses, traversals, and folds) returns at least 1 value.</p><p>Checking whether a list is non-empty:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>has each []
</code></strong>False
</pre><p>You can also use it with e.g. <code><a href="RIO-Lens.html#v:_Left" title="RIO.Lens">_Left</a></code> (and other 0-or-1 traversals) as a replacement for <code><a href="RIO-Prelude.html#v:isNothing" title="RIO.Prelude">isNothing</a></code>, <code><a href="RIO-Prelude.html#v:isJust" title="RIO.Prelude">isJust</a></code> and other <code>isConstructorName</code> functions:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>has _Left (Left 1)
</code></strong>True
</pre></div></div><a href="#g:2" id="g:2"><h1>Lens</h1></a><div class="top"><p class="src"><a id="v:_1" class="def">_1</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Field1" title="Lens.Micro.Internal">Field1</a> s t a b =&gt; <a href="RIO.html#t:Lens" title="RIO">Lens</a> s t a b <a href="#v:_1" class="selflink">#</a></p><div class="doc"><p>Gives access to the 1st field of a tuple (up to 5-tuples).</p><p>Getting the 1st component:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(1,2,3,4,5) ^. _1
</code></strong>1
</pre><p>Setting the 1st component:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(1,2,3) &amp; _1 .~ 10
</code></strong>(10,2,3)
</pre><p>Note that this lens is lazy, and can set fields even of <code><a href="RIO-Prelude.html#v:undefined" title="RIO.Prelude">undefined</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>set _1 10 undefined :: (Int, Int)
</code></strong>(10,*** Exception: Prelude.undefined
</pre><p>This is done to avoid violating a lens law stating that you can get back what you put:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>view _1 . set _1 10 $ (undefined :: (Int, Int))
</code></strong>10
</pre><p>The implementation (for 2-tuples) is:</p><pre><code><a href="RIO-Lens.html#v:_1" title="RIO.Lens">_1</a></code> f t = (,) <code><a href="RIO-Prelude.html#v:-60--36--62-" title="RIO.Prelude">&lt;$&gt;</a></code> f    (<code><a href="RIO-Prelude.html#v:fst" title="RIO.Prelude">fst</a></code> t)
             <code><a href="RIO-Prelude.html#v:-60--42--62-" title="RIO.Prelude">&lt;*&gt;</a></code> <code><a href="RIO-Prelude.html#v:pure" title="RIO.Prelude">pure</a></code> (<code><a href="RIO-Prelude.html#v:snd" title="RIO.Prelude">snd</a></code> t)
</pre><p>or, alternatively,</p><pre><code><a href="RIO-Lens.html#v:_1" title="RIO.Lens">_1</a></code> f ~(a,b) = (\a' -&gt; (a',b)) <code><a href="RIO-Prelude.html#v:-60--36--62-" title="RIO.Prelude">&lt;$&gt;</a></code> f a
</pre><p>(where <code>~</code> means a <a href="https://wiki.haskell.org/Lazy_pattern_match">lazy pattern</a>).</p><p><code><a href="RIO-Lens.html#v:_2" title="RIO.Lens">_2</a></code>, <code><a href="RIO-Lens.html#v:_3" title="RIO.Lens">_3</a></code>, <code><a href="RIO-Lens.html#v:_4" title="RIO.Lens">_4</a></code>, and <code><a href="RIO-Lens.html#v:_5" title="RIO.Lens">_5</a></code> are also available (see below).</p></div></div><div class="top"><p class="src"><a id="v:_2" class="def">_2</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Field2" title="Lens.Micro.Internal">Field2</a> s t a b =&gt; <a href="RIO.html#t:Lens" title="RIO">Lens</a> s t a b <a href="#v:_2" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:_3" class="def">_3</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Field3" title="Lens.Micro.Internal">Field3</a> s t a b =&gt; <a href="RIO.html#t:Lens" title="RIO">Lens</a> s t a b <a href="#v:_3" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:_4" class="def">_4</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Field4" title="Lens.Micro.Internal">Field4</a> s t a b =&gt; <a href="RIO.html#t:Lens" title="RIO">Lens</a> s t a b <a href="#v:_4" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:_5" class="def">_5</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Field5" title="Lens.Micro.Internal">Field5</a> s t a b =&gt; <a href="RIO.html#t:Lens" title="RIO">Lens</a> s t a b <a href="#v:_5" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:at" class="def">at</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:At" title="Lens.Micro.Internal">At</a> m =&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Index" title="Lens.Micro.Internal">Index</a> m -&gt; <a href="RIO.html#t:Lens-39-" title="RIO">Lens'</a> m (<a href="RIO-Prelude-Types.html#t:Maybe" title="RIO.Prelude.Types">Maybe</a> (<a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:IxValue" title="Lens.Micro.Internal">IxValue</a> m)) <a href="#v:at" class="selflink">#</a></p><div class="doc"><p>This lens lets you read, write, or delete elements in <code>Map</code>-like structures. It returns <code><a href="RIO-Prelude-Types.html#v:Nothing" title="RIO.Prelude.Types">Nothing</a></code> when the value isn't found, just like <code>lookup</code>:</p><pre>Data.Map.lookup k m = m <code><a href="../microlens-0.4.13.1/Lens-Micro.html#v:-94-." title="Lens.Micro">^.</a></code> at k
</pre><p>However, it also lets you insert and delete values by setting the value to <code><code><a href="RIO-Prelude-Types.html#v:Just" title="RIO.Prelude.Types">Just</a></code> value</code> or <code><a href="RIO-Prelude-Types.html#v:Nothing" title="RIO.Prelude.Types">Nothing</a></code>:</p><pre>Data.Map.insert k a m = m <code><a href="../microlens-0.4.13.1/Lens-Micro.html#v:-38-" title="Lens.Micro">&amp;</a></code> at k <code><a href="../microlens-0.4.13.1/Lens-Micro.html#v:.-126-" title="Lens.Micro">.~</a></code> Just a

Data.Map.delete k m = m <code><a href="../microlens-0.4.13.1/Lens-Micro.html#v:-38-" title="Lens.Micro">&amp;</a></code> at k <code><a href="../microlens-0.4.13.1/Lens-Micro.html#v:.-126-" title="Lens.Micro">.~</a></code> Nothing
</pre><p>Or you could use (<code><a href="../microlens-0.4.13.1/Lens-Micro.html#v:-63--126-" title="Lens.Micro">?~</a></code>) instead of (<code><a href="../microlens-0.4.13.1/Lens-Micro.html#v:.-126-" title="Lens.Micro">.~</a></code>):</p><pre>Data.Map.insert k a m = m <code><a href="../microlens-0.4.13.1/Lens-Micro.html#v:-38-" title="Lens.Micro">&amp;</a></code> at k <code><a href="../microlens-0.4.13.1/Lens-Micro.html#v:-63--126-" title="Lens.Micro">?~</a></code> a
</pre><p>Note that <code><a href="RIO-Lens.html#v:at" title="RIO.Lens">at</a></code> doesn't work for arrays or lists. You can't delete an arbitrary element from an array (what would be left in its place?), and you can't set an arbitrary element in a list because if the index is out of list's bounds, you'd have to somehow fill the stretch between the last element and the element you just inserted (i.e. <code>[1,2,3] &amp; at 10 .~ 5</code> is undefined). If you want to modify an already existing value in an array or list, you should use <code><a href="RIO-Lens.html#v:ix" title="RIO.Lens">ix</a></code> instead.</p><p><code><a href="RIO-Lens.html#v:at" title="RIO.Lens">at</a></code> is often used with <code><a href="../microlens-0.4.13.1/Lens-Micro.html#v:non" title="Lens.Micro">non</a></code>. See the documentation of <code><a href="../microlens-0.4.13.1/Lens-Micro.html#v:non" title="Lens.Micro">non</a></code> for examples.</p><p>Note that <code><a href="RIO-Lens.html#v:at" title="RIO.Lens">at</a></code> isn't strict for <code>Map</code>, even if you're using <code>Data.Map.Strict</code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Data.Map.Strict.size (Data.Map.Strict.empty &amp; at 1 .~ Just undefined)
</code></strong>1
</pre><p>The reason for such behavior is that there's actually no &#8220;strict <code>Map</code>&#8221; type; <code>Data.Map.Strict</code> just provides some strict functions for ordinary <code>Map</code>s.</p><p>This package doesn't actually provide any instances for <code><a href="RIO-Lens.html#v:at" title="RIO.Lens">at</a></code>, but there are instances for <code>Map</code> and <code>IntMap</code> in <a href="http://hackage.haskell.org/package/microlens-ghc">microlens-ghc</a> and an instance for <code>HashMap</code> in <a href="http://hackage.haskell.org/package/microlens-platform">microlens-platform</a>.</p></div></div><div class="top"><p class="src"><a id="v:lens" class="def">lens</a> :: (s -&gt; a) -&gt; (s -&gt; b -&gt; t) -&gt; <a href="RIO.html#t:Lens" title="RIO">Lens</a> s t a b <a href="#v:lens" class="selflink">#</a></p><div class="doc"><p><code><a href="RIO-Lens.html#v:lens" title="RIO.Lens">lens</a></code> creates a <code><a href="RIO.html#t:Lens" title="RIO">Lens</a></code> from a getter and a setter. The resulting lens isn't the most effective one (because of having to traverse the structure twice when modifying), but it shouldn't matter much.</p><p>A (partial) lens for list indexing:</p><pre>ix :: Int -&gt; <code><a href="RIO.html#t:Lens-39-" title="RIO">Lens'</a></code> [a] a
ix i = <code><a href="RIO-Lens.html#v:lens" title="RIO.Lens">lens</a></code> (<code><a href="RIO-List-Partial.html#v:-33--33-" title="RIO.List.Partial">!!</a></code> i)                                   -- getter
            (\s b -&gt; take i s ++ b : drop (i+1) s)   -- setter
</pre><p>Usage:</p><pre>&gt;&gt;&gt; [1..9] <code><a href="RIO.html#v:-94-." title="RIO">^.</a></code> ix 3
4

&gt;&gt;&gt; [1..9] &amp; ix 3 <code><a href="RIO.html#v:-37--126-" title="RIO">%~</a></code> negate
[1,2,3,-4,5,6,7,8,9]
</pre><p>When getting, the setter is completely unused; when setting, the getter is unused. Both are used only when the value is being modified. For instance, here we define a lens for the 1st element of a list, but instead of a legitimate getter we use <code><a href="RIO-Prelude.html#v:undefined" title="RIO.Prelude">undefined</a></code>. Then we use the resulting lens for <em>setting</em> and it works, which proves that the getter wasn't used:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[1,2,3] &amp; lens undefined (\s b -&gt; b : tail s) .~ 10
</code></strong>[10,2,3]
</pre></div></div><a href="#g:3" id="g:3"><h1>Iso</h1></a><div class="top"><p class="src"><a id="v:non" class="def">non</a> :: <a href="RIO-Prelude-Types.html#t:Eq" title="RIO.Prelude.Types">Eq</a> a =&gt; a -&gt; <a href="RIO.html#t:Lens-39-" title="RIO">Lens'</a> (<a href="RIO-Prelude-Types.html#t:Maybe" title="RIO.Prelude.Types">Maybe</a> a) a <a href="#v:non" class="selflink">#</a></p><div class="doc"><p><code><a href="RIO-Lens.html#v:non" title="RIO.Lens">non</a></code> lets you &#8220;relabel&#8221; a <code><a href="RIO-Prelude-Types.html#t:Maybe" title="RIO.Prelude.Types">Maybe</a></code> by equating <code><a href="RIO-Prelude-Types.html#v:Nothing" title="RIO.Prelude.Types">Nothing</a></code> to an arbitrary value (which you can choose):</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Just 1 ^. non 0
</code></strong>1
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Nothing ^. non 0
</code></strong>0
</pre><p>The most useful thing about <code><a href="RIO-Lens.html#v:non" title="RIO.Lens">non</a></code> is that relabeling also works in other direction. If you try to <code><a href="RIO.html#v:set" title="RIO">set</a></code> the &#8220;forbidden&#8221; value, it'll be turned to <code><a href="RIO-Prelude-Types.html#v:Nothing" title="RIO.Prelude.Types">Nothing</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Just 1 &amp; non 0 .~ 0
</code></strong>Nothing
</pre><p>Setting anything else works just fine:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Just 1 &amp; non 0 .~ 5
</code></strong>Just 5
</pre><p>Same happens if you try to modify a value:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Just 1 &amp; non 0 %~ subtract 1
</code></strong>Nothing
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Just 1 &amp; non 0 %~ (+ 1)
</code></strong>Just 2
</pre><p><code><a href="RIO-Lens.html#v:non" title="RIO.Lens">non</a></code> is often useful when combined with <code><a href="RIO-Lens.html#v:at" title="RIO.Lens">at</a></code>. For instance, if you have a map of songs and their playcounts, it makes sense not to store songs with 0 plays in the map; <code><a href="RIO-Lens.html#v:non" title="RIO.Lens">non</a></code> can act as a filter that wouldn't pass such entries.</p><p>Decrease playcount of a song to 0, and it'll be gone:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fromList [(&quot;Soon&quot;,1),(&quot;Yesterday&quot;,3)] &amp; at &quot;Soon&quot; . non 0 %~ subtract 1
</code></strong>fromList [(&quot;Yesterday&quot;,3)]
</pre><p>Try to add a song with 0 plays, and it won't be added:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fromList [(&quot;Yesterday&quot;,3)] &amp; at &quot;Soon&quot; . non 0 .~ 0
</code></strong>fromList [(&quot;Yesterday&quot;,3)]
</pre><p>But it will be added if you set any other number:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fromList [(&quot;Yesterday&quot;,3)] &amp; at &quot;Soon&quot; . non 0 .~ 1
</code></strong>fromList [(&quot;Soon&quot;,1),(&quot;Yesterday&quot;,3)]
</pre><p><code><a href="RIO-Lens.html#v:non" title="RIO.Lens">non</a></code> is also useful when working with nested maps. Here a nested map is created when it's missing:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Map.empty &amp; at &quot;Dez Mona&quot; . non Map.empty . at &quot;Soon&quot; .~ Just 1
</code></strong>fromList [(&quot;Dez Mona&quot;,fromList [(&quot;Soon&quot;,1)])]
</pre><p>and here it is deleted when its last entry is deleted (notice that <code><a href="RIO-Lens.html#v:non" title="RIO.Lens">non</a></code> is used twice here):</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fromList [(&quot;Dez Mona&quot;,fromList [(&quot;Soon&quot;,1)])] &amp; at &quot;Dez Mona&quot; . non Map.empty . at &quot;Soon&quot; . non 0 %~ subtract 1
</code></strong>fromList []
</pre><p>To understand the last example better, observe the flow of values in it:</p><ul><li>the map goes into <code>at &quot;Dez Mona&quot;</code></li><li>the nested map (wrapped into <code>Just</code>) goes into <code>non Map.empty</code></li><li><code>Just</code> is unwrapped and the nested map goes into <code>at &quot;Soon&quot;</code></li><li><code>Just 1</code> is unwrapped by <code>non 0</code></li></ul><p>Then the final value &#8211; i.e. 1 &#8211; is modified by <code>subtract 1</code> and the result (which is 0) starts flowing backwards:</p><ul><li><code>non 0</code> sees the 0 and produces a <code>Nothing</code></li><li><code>at &quot;Soon&quot;</code> sees <code>Nothing</code> and deletes the corresponding value from the map</li><li>the resulting empty map is passed to <code>non Map.empty</code>, which sees that it's empty and thus produces <code>Nothing</code></li><li><code>at &quot;Dez Mona&quot;</code> sees <code>Nothing</code> and removes the key from the map</li></ul></div></div><a href="#g:4" id="g:4"><h1>Traversal</h1></a><div class="top"><p class="src"><a id="v:singular" class="def">singular</a> :: <a href="RIO-Prelude-Types.html#t:HasCallStack" title="RIO.Prelude.Types">HasCallStack</a> =&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal" title="Lens.Micro.Type">Traversal</a> s t a a -&gt; <a href="RIO.html#t:Lens" title="RIO">Lens</a> s t a a <a href="#v:singular" class="selflink">#</a></p><div class="doc"><p><code><a href="RIO-Lens.html#v:singular" title="RIO.Lens">singular</a></code> turns a traversal into a lens that behaves like a single-element traversal:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[1,2,3] ^. singular each
</code></strong>1
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[1,2,3] &amp; singular each %~ negate
</code></strong>[-1,2,3]
</pre><p>If there is nothing to return, it'll throw an error:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[] ^. singular each
</code></strong>*** Exception: Lens.Micro.singular: empty traversal
</pre><p>However, it won't fail if you are merely setting the value:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[] &amp; singular each %~ negate
</code></strong></pre></div></div><div class="top"><p class="src"><a id="v:failing" class="def">failing</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal" title="Lens.Micro.Type">Traversal</a> s t a b -&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal" title="Lens.Micro.Type">Traversal</a> s t a b -&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal" title="Lens.Micro.Type">Traversal</a> s t a b <span class="fixity">infixl 5</span><span class="rightedge"></span> <a href="#v:failing" class="selflink">#</a></p><div class="doc"><p><code><a href="RIO-Lens.html#v:failing" title="RIO.Lens">failing</a></code> lets you chain traversals together; if the 1st traversal fails, the 2nd traversal will be used.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>([1,2],[3]) &amp; failing (_1.each) (_2.each) .~ 0
</code></strong>([0,0],[3])
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>([],[3]) &amp; failing (_1.each) (_2.each) .~ 0
</code></strong>([],[0])
</pre><p>Note that the resulting traversal won't be valid unless either both traversals don't touch each others' elements, or both traversals return exactly the same results. To see an example of how <code><a href="RIO-Lens.html#v:failing" title="RIO.Lens">failing</a></code> can generate invalid traversals, see <a href="http://stackoverflow.com/questions/27138856/why-does-failing-from-lens-produce-invalid-traversals">this Stackoverflow question</a>.</p></div></div><div class="top"><p class="src"><a id="v:filtered" class="def">filtered</a> :: (a -&gt; <a href="RIO-Prelude-Types.html#t:Bool" title="RIO.Prelude.Types">Bool</a>) -&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal-39-" title="Lens.Micro.Type">Traversal'</a> a a <a href="#v:filtered" class="selflink">#</a></p><div class="doc"><p><code><a href="RIO-Lens.html#v:filtered" title="RIO.Lens">filtered</a></code> is a traversal that filters elements &#8220;passing&#8221; through it:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(1,2,3,4) ^.. each
</code></strong>[1,2,3,4]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(1,2,3,4) ^.. each . filtered even
</code></strong>[2,4]
</pre><p>It also can be used to modify elements selectively:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(1,2,3,4) &amp; each . filtered even %~ (*100)
</code></strong>(1,200,3,400)
</pre><p>The implementation of <code><a href="RIO-Lens.html#v:filtered" title="RIO.Lens">filtered</a></code> is very simple. Consider this traversal, which always &#8220;traverses&#8221; just the value it's given:</p><pre>id :: <code><a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal-39-" title="Lens.Micro.Type">Traversal'</a></code> a a
id f s = f s
</pre><p>And this traversal, which traverses nothing (in other words, <em>doesn't</em> traverse the value it's given):</p><pre>ignored :: <code><a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal-39-" title="Lens.Micro.Type">Traversal'</a></code> a a
ignored f s = <code><a href="RIO-Prelude.html#v:pure" title="RIO.Prelude">pure</a></code> s
</pre><p>And now combine them into a traversal that conditionally traverses the value it's given, and you get <code><a href="RIO-Lens.html#v:filtered" title="RIO.Lens">filtered</a></code>:</p><pre>filtered :: (a -&gt; Bool) -&gt; <code><a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal-39-" title="Lens.Micro.Type">Traversal'</a></code> a a
filtered p f s = if p s then f s else <code><a href="RIO-Prelude.html#v:pure" title="RIO.Prelude">pure</a></code> s
</pre><p>By the way, note that <code><a href="RIO-Lens.html#v:filtered" title="RIO.Lens">filtered</a></code> can generate illegal traversals &#8211; sometimes this can bite you. In particular, an optimisation that should be safe becomes unsafe. (To the best of my knowledge, this optimisation never happens automatically. If you just use <code><a href="RIO-Lens.html#v:filtered" title="RIO.Lens">filtered</a></code> to modify/view something, you're safe. If you don't define any traversals that use <code><a href="RIO-Lens.html#v:filtered" title="RIO.Lens">filtered</a></code>, you're safe too.)</p><p>Let's use <code>evens</code> as an example:</p><pre>evens = <code><a href="RIO-Lens.html#v:filtered" title="RIO.Lens">filtered</a></code> <code><a href="RIO-Prelude.html#v:even" title="RIO.Prelude">even</a></code>
</pre><p>If <code>evens</code> was a legal traversal, you'd be able to fuse several applications of <code>evens</code> like this:</p><pre><code><a href="RIO.html#v:over" title="RIO">over</a></code> evens f <code><a href="RIO-Prelude.html#v:." title="RIO.Prelude">.</a></code> <code><a href="RIO.html#v:over" title="RIO">over</a></code> evens g = <code><a href="RIO.html#v:over" title="RIO">over</a></code> evens (f <code><a href="RIO-Prelude.html#v:." title="RIO.Prelude">.</a></code> g)
</pre><p>Unfortunately, in case of <code>evens</code> this isn't a correct optimisation:</p><ul><li>the left-side variant applies <code>g</code> to all even numbers, and then applies <code>f</code> to all even numbers that are left after <code>f</code> (because <code>f</code> might've turned some even numbers into odd ones)</li><li>the right-side variant applies <code>f</code> and <code>g</code> to all even numbers</li></ul><p>Of course, when you are careful and know what you're doing, you won't try to make such an optimisation. However, if you export an illegal traversal created with <code><a href="RIO-Lens.html#v:filtered" title="RIO.Lens">filtered</a></code> and someone tries to use it, they might mistakenly assume that it's legal, do the optimisation, and silently get an incorrect result.</p><p>If you are using <code><a href="RIO-Lens.html#v:filtered" title="RIO.Lens">filtered</a></code> with some another traversal that doesn't overlap with -whatever the predicate checks-, the resulting traversal will be legal. For instance, here the predicate looks at the 1st element of a tuple, but the resulting traversal only gives you access to the 2nd:</p><pre>pairedWithEvens :: <code><a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal" title="Lens.Micro.Type">Traversal</a></code> [(Int, a)] [(Int, b)] a b
pairedWithEvens = <code><a href="RIO-Lens.html#v:each" title="RIO.Lens">each</a></code> <code><a href="RIO-Prelude.html#v:." title="RIO.Prelude">.</a></code> <code><a href="RIO-Lens.html#v:filtered" title="RIO.Lens">filtered</a></code> (<code><a href="RIO-Prelude.html#v:even" title="RIO.Prelude">even</a></code> <code><a href="RIO-Prelude.html#v:." title="RIO.Prelude">.</a></code> <code><a href="RIO-Prelude.html#v:fst" title="RIO.Prelude">fst</a></code>) <code><a href="RIO-Prelude.html#v:." title="RIO.Prelude">.</a></code> <code><a href="RIO-Lens.html#v:_2" title="RIO.Lens">_2</a></code>
</pre><p>Since you can't do anything with the 1st components through this traversal, the following holds for any <code>f</code> and <code>g</code>:</p><pre><code><a href="RIO.html#v:over" title="RIO">over</a></code> pairedWithEvens f <code><a href="RIO-Prelude.html#v:." title="RIO.Prelude">.</a></code> <code><a href="RIO.html#v:over" title="RIO">over</a></code> pairedWithEvens g = <code><a href="RIO.html#v:over" title="RIO">over</a></code> pairedWithEvens (f <code><a href="RIO-Prelude.html#v:." title="RIO.Prelude">.</a></code> g)
</pre></div></div><div class="top"><p class="src"><a id="v:both" class="def">both</a> :: <span class="keyword">forall</span> a b f. <a href="RIO-Prelude-Types.html#t:Applicative" title="RIO.Prelude.Types">Applicative</a> f =&gt; (a -&gt; f b) -&gt; (a, a) -&gt; f (b, b) <a href="#v:both" class="selflink">#</a></p><div class="doc"><p><code><a href="RIO-Lens.html#v:both" title="RIO.Lens">both</a></code> traverses both fields of a tuple. Unlike <code><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:both">both</a></code> from lens, it only works for pairs &#8211; not for triples or <code><a href="RIO-Prelude-Types.html#t:Either" title="RIO.Prelude.Types">Either</a></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(&quot;str&quot;,&quot;ing&quot;) ^. both
</code></strong>&quot;string&quot;
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(&quot;str&quot;,&quot;ing&quot;) &amp; both %~ reverse
</code></strong>(&quot;rts&quot;,&quot;gni&quot;)
</pre></div></div><div class="top"><p class="src"><a id="v:traversed" class="def">traversed</a> :: <span class="keyword">forall</span> (f :: <a href="../base-4.18.2.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="../base-4.18.2.0/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a b. <a href="RIO-Prelude-Types.html#t:Traversable" title="RIO.Prelude.Types">Traversable</a> f =&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal" title="Lens.Micro.Type">Traversal</a> (f a) (f b) a b <a href="#v:traversed" class="selflink">#</a></p><div class="doc"><p><code><a href="RIO-Lens.html#v:traversed" title="RIO.Lens">traversed</a></code> traverses any <code><a href="RIO-Prelude-Types.html#t:Traversable" title="RIO.Prelude.Types">Traversable</a></code> container (list, vector, <code>Map</code>, <code><a href="RIO-Prelude-Types.html#t:Maybe" title="RIO.Prelude.Types">Maybe</a></code>, you name it):</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Just 1 ^.. traversed
</code></strong>[1]
</pre><p><code><a href="RIO-Lens.html#v:traversed" title="RIO.Lens">traversed</a></code> is the same as <code><a href="RIO-Prelude.html#v:traverse" title="RIO.Prelude">traverse</a></code>, but can be faster thanks to magic rewrite rules.</p></div></div><div class="top"><p class="src"><a id="v:each" class="def">each</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Each" title="Lens.Micro.Internal">Each</a> s t a b =&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal" title="Lens.Micro.Type">Traversal</a> s t a b <a href="#v:each" class="selflink">#</a></p><div class="doc"><p><code><a href="RIO-Lens.html#v:each" title="RIO.Lens">each</a></code> tries to be a universal <code><a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal" title="Lens.Micro.Type">Traversal</a></code> &#8211; it behaves like <code><a href="RIO-Lens.html#v:traversed" title="RIO.Lens">traversed</a></code> in most situations, but also adds support for e.g. tuples with same-typed values:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(1,2) &amp; each %~ succ
</code></strong>(2,3)
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;] ^. each
</code></strong>&quot;xyz&quot;
</pre><p>However, note that <code><a href="RIO-Lens.html#v:each" title="RIO.Lens">each</a></code> doesn't work on <em>every</em> instance of <code><a href="RIO-Prelude-Types.html#t:Traversable" title="RIO.Prelude.Types">Traversable</a></code>. If you have a <code><a href="RIO-Prelude-Types.html#t:Traversable" title="RIO.Prelude.Types">Traversable</a></code> which isn't supported by <code><a href="RIO-Lens.html#v:each" title="RIO.Lens">each</a></code>, you can use <code><a href="RIO-Lens.html#v:traversed" title="RIO.Lens">traversed</a></code> instead. Personally, I like using <code><a href="RIO-Lens.html#v:each" title="RIO.Lens">each</a></code> instead of <code><a href="RIO-Lens.html#v:traversed" title="RIO.Lens">traversed</a></code> whenever possible &#8211; it's shorter and more descriptive.</p><p>You can use <code><a href="RIO-Lens.html#v:each" title="RIO.Lens">each</a></code> with these things:</p><pre><code><a href="RIO-Lens.html#v:each" title="RIO.Lens">each</a></code> :: <code><a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal" title="Lens.Micro.Type">Traversal</a></code> [a] [b] a b

<code><a href="RIO-Lens.html#v:each" title="RIO.Lens">each</a></code> :: <code><a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal" title="Lens.Micro.Type">Traversal</a></code> (<code><a href="RIO-Prelude-Types.html#t:Maybe" title="RIO.Prelude.Types">Maybe</a></code> a) (<code><a href="RIO-Prelude-Types.html#t:Maybe" title="RIO.Prelude.Types">Maybe</a></code> b) a b
<code><a href="RIO-Lens.html#v:each" title="RIO.Lens">each</a></code> :: <code><a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal" title="Lens.Micro.Type">Traversal</a></code> (<code><a href="RIO-Prelude-Types.html#t:Either" title="RIO.Prelude.Types">Either</a></code> a a) (<code><a href="RIO-Prelude-Types.html#t:Either" title="RIO.Prelude.Types">Either</a></code> b b) a b  -- since 0.4.11

<code><a href="RIO-Lens.html#v:each" title="RIO.Lens">each</a></code> :: <code><a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal" title="Lens.Micro.Type">Traversal</a></code> (a,a) (b,b) a b
<code><a href="RIO-Lens.html#v:each" title="RIO.Lens">each</a></code> :: <code><a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal" title="Lens.Micro.Type">Traversal</a></code> (a,a,a) (b,b,b) a b
<code><a href="RIO-Lens.html#v:each" title="RIO.Lens">each</a></code> :: <code><a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal" title="Lens.Micro.Type">Traversal</a></code> (a,a,a,a) (b,b,b,b) a b
<code><a href="RIO-Lens.html#v:each" title="RIO.Lens">each</a></code> :: <code><a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal" title="Lens.Micro.Type">Traversal</a></code> (a,a,a,a,a) (b,b,b,b,b) a b

<code><a href="RIO-Lens.html#v:each" title="RIO.Lens">each</a></code> :: (<code><a href="RIO-Prelude-Types.html#t:RealFloat" title="RIO.Prelude.Types">RealFloat</a></code> a, <code><a href="RIO-Prelude-Types.html#t:RealFloat" title="RIO.Prelude.Types">RealFloat</a></code> b) =&gt; <code><a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal" title="Lens.Micro.Type">Traversal</a></code> (<code><a href="../base-4.18.2.0/Data-Complex.html#t:Complex" title="Data.Complex">Complex</a></code> a) (<code><a href="../base-4.18.2.0/Data-Complex.html#t:Complex" title="Data.Complex">Complex</a></code> b) a b
</pre><p>You can also use <code><a href="RIO-Lens.html#v:each" title="RIO.Lens">each</a></code> with types from <a href="http://hackage.haskell.org/package/array">array</a>, <a href="http://hackage.haskell.org/package/bytestring">bytestring</a>, and <a href="http://hackage.haskell.org/package/containers">containers</a> by using <a href="http://hackage.haskell.org/package/microlens-ghc">microlens-ghc</a>, or additionally with types from <a href="http://hackage.haskell.org/package/vector">vector</a>, <a href="http://hackage.haskell.org/package/text">text</a>, and <a href="http://hackage.haskell.org/package/unordered-containers">unordered-containers</a> by using <a href="http://hackage.haskell.org/package/microlens-platform">microlens-platform</a>.</p></div></div><div class="top"><p class="src"><a id="v:ix" class="def">ix</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Ixed" title="Lens.Micro.Internal">Ixed</a> m =&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Index" title="Lens.Micro.Internal">Index</a> m -&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal-39-" title="Lens.Micro.Type">Traversal'</a> m (<a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:IxValue" title="Lens.Micro.Internal">IxValue</a> m) <a href="#v:ix" class="selflink">#</a></p><div class="doc"><p>This traversal lets you access (and update) an arbitrary element in a list, array, <code>Map</code>, etc. (If you want to insert or delete elements as well, look at <code><a href="RIO-Lens.html#v:at" title="RIO.Lens">at</a></code>.)</p><p>An example for lists:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[0..5] &amp; ix 3 .~ 10
</code></strong>[0,1,2,10,4,5]
</pre><p>You can use it for getting, too:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[0..5] ^? ix 3
</code></strong>Just 3
</pre><p>Of course, the element may not be present (which means that you can use <code><a href="RIO-Lens.html#v:ix" title="RIO.Lens">ix</a></code> as a safe variant of (<code><a href="RIO-List-Partial.html#v:-33--33-" title="RIO.List.Partial">!!</a></code>)):</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[0..5] ^? ix 10
</code></strong>Nothing
</pre><p>Another useful instance is the one for functions &#8211; it lets you modify their outputs for specific inputs. For instance, here's <code><a href="RIO-List-Partial.html#v:maximum" title="RIO.List.Partial">maximum</a></code> that returns 0 when the list is empty (instead of throwing an exception):</p><pre>maximum0 = <code><a href="RIO-List-Partial.html#v:maximum" title="RIO.List.Partial">maximum</a></code> <code><a href="../microlens-0.4.13.1/Lens-Micro.html#v:-38-" title="Lens.Micro">&amp;</a></code> <code><a href="RIO-Lens.html#v:ix" title="RIO.Lens">ix</a></code> [] <code><a href="../microlens-0.4.13.1/Lens-Micro.html#v:.-126-" title="Lens.Micro">.~</a></code> 0
</pre><p>The following instances are provided in this package:</p><pre><code><a href="RIO-Lens.html#v:ix" title="RIO.Lens">ix</a></code> :: <code><a href="RIO-Prelude-Types.html#t:Int" title="RIO.Prelude.Types">Int</a></code> -&gt; <code><a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal-39-" title="Lens.Micro.Type">Traversal'</a></code> [a] a

<code><a href="RIO-Lens.html#v:ix" title="RIO.Lens">ix</a></code> :: <code><a href="RIO-Prelude-Types.html#t:Int" title="RIO.Prelude.Types">Int</a></code> -&gt; <code><a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal-39-" title="Lens.Micro.Type">Traversal'</a></code> (NonEmpty a) a

<code><a href="RIO-Lens.html#v:ix" title="RIO.Lens">ix</a></code> :: (<code><a href="RIO-Prelude-Types.html#t:Eq" title="RIO.Prelude.Types">Eq</a></code> e) =&gt; e -&gt; <code><a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal-39-" title="Lens.Micro.Type">Traversal'</a></code> (e -&gt; a) a
</pre><p>You can also use <code><a href="RIO-Lens.html#v:ix" title="RIO.Lens">ix</a></code> with types from <a href="http://hackage.haskell.org/package/array">array</a>, <a href="http://hackage.haskell.org/package/bytestring">bytestring</a>, and <a href="http://hackage.haskell.org/package/containers">containers</a> by using <a href="http://hackage.haskell.org/package/microlens-ghc">microlens-ghc</a>, or additionally with types from <a href="http://hackage.haskell.org/package/vector">vector</a>, <a href="http://hackage.haskell.org/package/text">text</a>, and <a href="http://hackage.haskell.org/package/unordered-containers">unordered-containers</a> by using <a href="http://hackage.haskell.org/package/microlens-platform">microlens-platform</a>.</p></div></div><div class="top"><p class="src"><a id="v:_head" class="def">_head</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Cons" title="Lens.Micro.Internal">Cons</a> s s a a =&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal-39-" title="Lens.Micro.Type">Traversal'</a> s a <a href="#v:_head" class="selflink">#</a></p><div class="doc"><p><code><a href="RIO-Lens.html#v:_head" title="RIO.Lens">_head</a></code> traverses the 1st element of something (usually a list, but can also be a <code>Seq</code>, etc):</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[1..5] ^? _head
</code></strong>Just 1
</pre><p>It can be used to modify too, as in this example where the 1st letter of a sentence is capitalised:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>&quot;mary had a little lamb.&quot; &amp; _head %~ toTitle
</code></strong>&quot;Mary had a little lamb.&quot;
</pre><p>The reason it's a traversal and not a lens is that there's nothing to traverse when the list is empty:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[] ^? _head
</code></strong>Nothing
</pre><p>This package only lets you use <code><a href="RIO-Lens.html#v:_head" title="RIO.Lens">_head</a></code> on lists, but if you use <a href="http://hackage.haskell.org/package/microlens-ghc">microlens-ghc</a> you get instances for <code>ByteString</code> and <code>Seq</code>, and if you use <a href="http://hackage.haskell.org/package/microlens-platform">microlens-platform</a> you additionally get instances for <code>Text</code> and <code>Vector</code>.</p></div></div><div class="top"><p class="src"><a id="v:_tail" class="def">_tail</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Cons" title="Lens.Micro.Internal">Cons</a> s s a a =&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal-39-" title="Lens.Micro.Type">Traversal'</a> s s <a href="#v:_tail" class="selflink">#</a></p><div class="doc"><p><code><a href="RIO-Lens.html#v:_tail" title="RIO.Lens">_tail</a></code> gives you access to the tail of a list (or <code>Seq</code>, etc):</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[1..5] ^? _tail
</code></strong>Just [2,3,4,5]
</pre><p>You can modify the tail as well:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[4,1,2,3] &amp; _tail %~ reverse
</code></strong>[4,3,2,1]
</pre><p>Since lists are monoids, you can use <code><a href="RIO-Lens.html#v:_tail" title="RIO.Lens">_tail</a></code> with plain (<code><a href="RIO.html#v:-94-." title="RIO">^.</a></code>) (and then it'll return an empty list if you give it an empty list):</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[1..5] ^. _tail
</code></strong>[2,3,4,5]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[] ^. _tail
</code></strong>[]
</pre><p>If you want to traverse each <em>element</em> of the tail, use <code><a href="RIO-Lens.html#v:_tail" title="RIO.Lens">_tail</a></code> with <code><a href="RIO-Lens.html#v:each" title="RIO.Lens">each</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>&quot;I HATE CAPS.&quot; &amp; _tail.each %~ toLower
</code></strong>&quot;I hate caps.&quot;
</pre><p>This package only lets you use <code><a href="RIO-Lens.html#v:_tail" title="RIO.Lens">_tail</a></code> on lists, but if you use <a href="http://hackage.haskell.org/package/microlens-ghc">microlens-ghc</a> you get instances for <code>ByteString</code> and <code>Seq</code>, and if you use <a href="http://hackage.haskell.org/package/microlens-platform">microlens-platform</a> you additionally get instances for <code>Text</code> and <code>Vector</code>.</p></div></div><div class="top"><p class="src"><a id="v:_init" class="def">_init</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Snoc" title="Lens.Micro.Internal">Snoc</a> s s a a =&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal-39-" title="Lens.Micro.Type">Traversal'</a> s s <a href="#v:_init" class="selflink">#</a></p><div class="doc"><p><code><a href="RIO-Lens.html#v:_init" title="RIO.Lens">_init</a></code> gives you access to all-but-the-last elements of the list:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>&quot;Hello.&quot; ^. _init
</code></strong>&quot;Hello&quot;
</pre><p>See documentation for <code><a href="RIO-Lens.html#v:_tail" title="RIO.Lens">_tail</a></code>, as <code><a href="RIO-Lens.html#v:_init" title="RIO.Lens">_init</a></code> and <code><a href="RIO-Lens.html#v:_tail" title="RIO.Lens">_tail</a></code> are pretty similar.</p></div></div><div class="top"><p class="src"><a id="v:_last" class="def">_last</a> :: <a href="../microlens-0.4.13.1/Lens-Micro-Internal.html#t:Snoc" title="Lens.Micro.Internal">Snoc</a> s s a a =&gt; <a href="../microlens-0.4.13.1/Lens-Micro-Type.html#t:Traversal-39-" title="Lens.Micro.Type">Traversal'</a> s a <a href="#v:_last" class="selflink">#</a></p><div class="doc"><p><code><a href="RIO-Lens.html#v:_last" title="RIO.Lens">_last</a></code> gives you access to the last element of the list:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>&quot;Hello.&quot; ^? _last
</code></strong>'.'
</pre><p>See documentation for <code><a href="RIO-Lens.html#v:_head" title="RIO.Lens">_head</a></code>, as <code><a href="RIO-Lens.html#v:_last" title="RIO.Lens">_last</a></code> and <code><a href="RIO-Lens.html#v:_head" title="RIO.Lens">_head</a></code> are pretty similar.</p></div></div><a href="#g:5" id="g:5"><h1>Prism</h1></a><div class="top"><p class="src"><a id="v:_Left" class="def">_Left</a> :: <span class="keyword">forall</span> a b a' f. <a href="RIO-Prelude-Types.html#t:Applicative" title="RIO.Prelude.Types">Applicative</a> f =&gt; (a -&gt; f a') -&gt; <a href="RIO-Prelude-Types.html#t:Either" title="RIO.Prelude.Types">Either</a> a b -&gt; f (<a href="RIO-Prelude-Types.html#t:Either" title="RIO.Prelude.Types">Either</a> a' b) <a href="#v:_Left" class="selflink">#</a></p><div class="doc"><p><code><a href="RIO-Lens.html#v:_Left" title="RIO.Lens">_Left</a></code> targets the value contained in an <code><a href="RIO-Prelude-Types.html#t:Either" title="RIO.Prelude.Types">Either</a></code>, provided it's a <code><a href="RIO-Prelude-Types.html#v:Left" title="RIO.Prelude.Types">Left</a></code>.</p><p>Gathering all <code>Left</code>s in a structure (like the <code><a href="../base-4.18.2.0/Data-Either.html#v:lefts" title="Data.Either">lefts</a></code> function, but not necessarily just for lists):</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[Left 1, Right 'c', Left 3] ^.. each._Left
</code></strong>[1,3]
</pre><p>Checking whether an <code><a href="RIO-Prelude-Types.html#t:Either" title="RIO.Prelude.Types">Either</a></code> is a <code><a href="RIO-Prelude-Types.html#v:Left" title="RIO.Prelude.Types">Left</a></code> (like <code><a href="../base-4.18.2.0/Data-Either.html#v:isLeft" title="Data.Either">isLeft</a></code>):</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>has _Left (Left 1)
</code></strong>True
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>has _Left (Right 1)
</code></strong>False
</pre><p>Extracting a value (if you're sure it's a <code><a href="RIO-Prelude-Types.html#v:Left" title="RIO.Prelude.Types">Left</a></code>):</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Left 1 ^?! _Left
</code></strong>1
</pre><p>Mapping over all <code><a href="RIO-Prelude-Types.html#v:Left" title="RIO.Prelude.Types">Left</a></code>s:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(each._Left %~ map toUpper) [Left &quot;foo&quot;, Right &quot;bar&quot;]
</code></strong>[Left &quot;FOO&quot;,Right &quot;bar&quot;]
</pre><p>Implementation:</p><pre><code><a href="RIO-Lens.html#v:_Left" title="RIO.Lens">_Left</a></code> f (Left a)  = <code><a href="RIO-Prelude-Types.html#v:Left" title="RIO.Prelude.Types">Left</a></code> <code><a href="RIO-Prelude.html#v:-60--36--62-" title="RIO.Prelude">&lt;$&gt;</a></code> f a
<code><a href="RIO-Lens.html#v:_Left" title="RIO.Lens">_Left</a></code> _ (Right b) = <code><a href="RIO-Prelude.html#v:pure" title="RIO.Prelude">pure</a></code> (<code><a href="RIO-Prelude-Types.html#v:Right" title="RIO.Prelude.Types">Right</a></code> b)
</pre></div></div><div class="top"><p class="src"><a id="v:_Right" class="def">_Right</a> :: <span class="keyword">forall</span> a b b' f. <a href="RIO-Prelude-Types.html#t:Applicative" title="RIO.Prelude.Types">Applicative</a> f =&gt; (b -&gt; f b') -&gt; <a href="RIO-Prelude-Types.html#t:Either" title="RIO.Prelude.Types">Either</a> a b -&gt; f (<a href="RIO-Prelude-Types.html#t:Either" title="RIO.Prelude.Types">Either</a> a b') <a href="#v:_Right" class="selflink">#</a></p><div class="doc"><p><code><a href="RIO-Lens.html#v:_Right" title="RIO.Lens">_Right</a></code> targets the value contained in an <code><a href="RIO-Prelude-Types.html#t:Either" title="RIO.Prelude.Types">Either</a></code>, provided it's a <code><a href="RIO-Prelude-Types.html#v:Right" title="RIO.Prelude.Types">Right</a></code>.</p><p>See documentation for <code><a href="RIO-Lens.html#v:_Left" title="RIO.Lens">_Left</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:_Just" class="def">_Just</a> :: <span class="keyword">forall</span> a a' f. <a href="RIO-Prelude-Types.html#t:Applicative" title="RIO.Prelude.Types">Applicative</a> f =&gt; (a -&gt; f a') -&gt; <a href="RIO-Prelude-Types.html#t:Maybe" title="RIO.Prelude.Types">Maybe</a> a -&gt; f (<a href="RIO-Prelude-Types.html#t:Maybe" title="RIO.Prelude.Types">Maybe</a> a') <a href="#v:_Just" class="selflink">#</a></p><div class="doc"><p><code><a href="RIO-Lens.html#v:_Just" title="RIO.Lens">_Just</a></code> targets the value contained in a <code><a href="RIO-Prelude-Types.html#t:Maybe" title="RIO.Prelude.Types">Maybe</a></code>, provided it's a <code><a href="RIO-Prelude-Types.html#v:Just" title="RIO.Prelude.Types">Just</a></code>.</p><p>See documentation for <code><a href="RIO-Lens.html#v:_Left" title="RIO.Lens">_Left</a></code> (as these 2 are pretty similar). In particular, it can be used to write these:</p><ul><li>Unsafely extracting a value from a <code><a href="RIO-Prelude-Types.html#v:Just" title="RIO.Prelude.Types">Just</a></code>:</li></ul><pre>   <code><a href="RIO-Partial.html#v:fromJust" title="RIO.Partial">fromJust</a></code> = (<code><a href="../microlens-0.4.13.1/Lens-Micro.html#v:-94--63--33-" title="Lens.Micro">^?!</a></code> <code><a href="RIO-Lens.html#v:_Just" title="RIO.Lens">_Just</a></code>)
   </pre><ul><li>Checking whether a value is a <code><a href="RIO-Prelude-Types.html#v:Just" title="RIO.Prelude.Types">Just</a></code>:</li></ul><pre>   <code><a href="RIO-Prelude.html#v:isJust" title="RIO.Prelude">isJust</a></code> = <code><a href="RIO-Lens.html#v:has" title="RIO.Lens">has</a></code> <code><a href="RIO-Lens.html#v:_Just" title="RIO.Lens">_Just</a></code>
   </pre><ul><li>Converting a <code><a href="RIO-Prelude-Types.html#t:Maybe" title="RIO.Prelude.Types">Maybe</a></code> to a list (empty or consisting of a single element):</li></ul><pre>   <code><a href="RIO-Prelude.html#v:maybeToList" title="RIO.Prelude">maybeToList</a></code> = (<code><a href="RIO.html#v:-94-.." title="RIO">^..</a></code> <code><a href="RIO-Lens.html#v:_Just" title="RIO.Lens">_Just</a></code>)
   </pre><ul><li>Gathering all <code><a href="RIO-Prelude-Types.html#v:Just" title="RIO.Prelude.Types">Just</a></code>s in a list:</li></ul><pre>   <code><a href="RIO-Prelude.html#v:catMaybes" title="RIO.Prelude">catMaybes</a></code> = (<code><a href="RIO.html#v:-94-.." title="RIO">^..</a></code> <code><a href="RIO-Lens.html#v:each" title="RIO.Lens">each</a></code> <code><a href="RIO-Prelude.html#v:." title="RIO.Prelude">.</a></code> <code><a href="RIO-Lens.html#v:_Just" title="RIO.Lens">_Just</a></code>)
   </pre></div></div><div class="top"><p class="src"><a id="v:_Nothing" class="def">_Nothing</a> :: <span class="keyword">forall</span> a f. <a href="RIO-Prelude-Types.html#t:Applicative" title="RIO.Prelude.Types">Applicative</a> f =&gt; (() -&gt; f ()) -&gt; <a href="RIO-Prelude-Types.html#t:Maybe" title="RIO.Prelude.Types">Maybe</a> a -&gt; f (<a href="RIO-Prelude-Types.html#t:Maybe" title="RIO.Prelude.Types">Maybe</a> a) <a href="#v:_Nothing" class="selflink">#</a></p><div class="doc"><p><code><a href="RIO-Lens.html#v:_Nothing" title="RIO.Lens">_Nothing</a></code> targets a <code>()</code> if the <code><a href="RIO-Prelude-Types.html#t:Maybe" title="RIO.Prelude.Types">Maybe</a></code> is a <code><a href="RIO-Prelude-Types.html#v:Nothing" title="RIO.Prelude.Types">Nothing</a></code>, and doesn't target anything otherwise:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Just 1 ^.. _Nothing
</code></strong>[]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Nothing ^.. _Nothing
</code></strong>[()]
</pre><p>It's not particularly useful (unless you want to use <code><code><a href="RIO-Lens.html#v:has" title="RIO.Lens">has</a></code> <code><a href="RIO-Lens.html#v:_Nothing" title="RIO.Lens">_Nothing</a></code></code> as a replacement for <code><a href="RIO-Prelude.html#v:isNothing" title="RIO.Prelude">isNothing</a></code>), and provided mainly for consistency.</p><p>Implementation:</p><pre><code><a href="RIO-Lens.html#v:_Nothing" title="RIO.Lens">_Nothing</a></code> f Nothing = <code><a href="RIO-Prelude.html#v:const" title="RIO.Prelude">const</a></code> <code><a href="RIO-Prelude-Types.html#v:Nothing" title="RIO.Prelude.Types">Nothing</a></code> <code><a href="RIO-Prelude.html#v:-60--36--62-" title="RIO.Prelude">&lt;$&gt;</a></code> f ()
<code><a href="RIO-Lens.html#v:_Nothing" title="RIO.Lens">_Nothing</a></code> _ j       = <code><a href="RIO-Prelude.html#v:pure" title="RIO.Prelude">pure</a></code> j
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>