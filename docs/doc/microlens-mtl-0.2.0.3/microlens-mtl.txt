-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | microlens support for Reader/Writer/State from mtl
--   
--   This package contains functions (like <a>view</a> or <a>+=</a>) which
--   work on <a>MonadReader</a>, <a>MonadWriter</a>, and <a>MonadState</a>
--   from the mtl package.
--   
--   This package is a part of the <a>microlens</a> family; see the readme
--   <a>on Github</a>.
@package microlens-mtl
@version 0.2.0.3


-- | This module lets you define your own instances of <a>Zoom</a> and
--   <a>Magnify</a>.
--   
--   The warning from <a>Lens.Micro.Internal</a> applies to this module as
--   well. Don't export functions that have <a>Zoom</a> or <a>Magnify</a>
--   in their type signatures. If you absolutely need to define an instance
--   (e.g. for internal use), only do it for your own types, because
--   otherwise I might add an instance to one of the microlens packages
--   later and if our instances are different it might lead to subtle bugs.
module Lens.Micro.Mtl.Internal

-- | This type family is used by <a>Zoom</a> to describe the common effect
--   type.
type family Zoomed (m :: Type -> Type) :: Type -> Type -> Type
class (MonadState s m, MonadState t n) => Zoom m n s t | m -> s, n -> t, m t -> n, n s -> m

-- | When you're in a state monad, this function lets you operate on a part
--   of your state. For instance, if your state was a record containing a
--   <tt>position</tt> field, after zooming <tt>position</tt> would become
--   your whole state (and when you modify it, the bigger structure would
--   be modified as well).
--   
--   (Your <a>State</a> / <a>StateT</a> or <a>RWS</a> / <a>RWST</a> can be
--   anywhere in the stack, but you can't use <a>zoom</a> with arbitrary
--   <a>MonadState</a> because it doesn't provide any methods to change the
--   type of the state. See <a>this issue</a> for details.)
--   
--   For the sake of the example, let's define some types first:
--   
--   <pre>
--   data Position = Position {
--     _x, _y :: Int }
--   
--   data Player = Player {
--     _position :: Position,
--     ... }
--   
--   data Game = Game {
--     _player :: Player,
--     _obstacles :: [Position],
--     ... }
--   
--   concat &lt;$&gt; mapM makeLenses [''Position, ''Player, ''Game]
--   </pre>
--   
--   Now, here's an action that moves the player north-east:
--   
--   <pre>
--   moveNE :: <a>State</a> Game ()
--   moveNE = do
--     player.position.x <a>+=</a> 1
--     player.position.y <a>+=</a> 1
--   </pre>
--   
--   With <a>zoom</a>, you can use <tt>player.position</tt> to focus just
--   on a part of the state:
--   
--   <pre>
--   moveNE :: <a>State</a> Game ()
--   moveNE = do
--     <a>zoom</a> (player.position) $ do
--       x <a>+=</a> 1
--       y <a>+=</a> 1
--   </pre>
--   
--   You can just as well use it for retrieving things out of the state:
--   
--   <pre>
--   getCoords :: <a>State</a> Game (Int, Int)
--   getCoords = <a>zoom</a> (player.position) ((,) <a>&lt;$&gt;</a> <a>use</a> x <a>&lt;*&gt;</a> <a>use</a> y)
--   </pre>
--   
--   Or more explicitly:
--   
--   <pre>
--   getCoords = <a>zoom</a> (player.position) $ do
--     x' &lt;- <a>use</a> x
--     y' &lt;- <a>use</a> y
--     return (x', y')
--   </pre>
--   
--   When you pass a traversal to <a>zoom</a>, it'll work as a loop. For
--   instance, here we move all obstacles:
--   
--   <pre>
--   moveObstaclesNE :: <a>State</a> Game ()
--   moveObstaclesNE = do
--     <a>zoom</a> (obstacles.<a>each</a>) $ do
--       x <a>+=</a> 1
--       y <a>+=</a> 1
--   </pre>
--   
--   If the action returns a result, all results would be combined with
--   <a>&lt;&gt;</a> – the same way they're combined when <a>^.</a> is
--   passed a traversal. In this example, <tt>moveObstaclesNE</tt> returns
--   a list of old coordinates of obstacles in addition to moving them:
--   
--   <pre>
--   moveObstaclesNE = do
--     xys &lt;- <a>zoom</a> (obstacles.<a>each</a>) $ do
--       -- Get old coordinates.
--       x' &lt;- <a>use</a> x
--       y' &lt;- <a>use</a> y
--       -- Update them.
--       x <a>.=</a> x' + 1
--       y <a>.=</a> y' + 1
--       -- Return a single-element list with old coordinates.
--       return [(x', y')]
--     ...
--   </pre>
--   
--   Finally, you might need to write your own instances of <a>Zoom</a> if
--   you use <tt>newtype</tt>d transformers in your monad stack. This can
--   be done as follows:
--   
--   <pre>
--   import <a>Lens.Micro.Mtl.Internal</a>
--   
--   type instance <a>Zoomed</a> (MyStateT s m) = <a>Zoomed</a> (StateT s m)
--   
--   instance Monad m =&gt; <a>Zoom</a> (MyStateT s m) (MyStateT t m) s t where
--       <a>zoom</a> l (MyStateT m) = MyStateT (<a>zoom</a> l m)
--   </pre>
zoom :: Zoom m n s t => LensLike' (Zoomed m c) t s -> m c -> n c
infixr 2 `zoom`

-- | This type family is used by <a>Magnify</a> to describe the common
--   effect type.
type family Magnified (m :: Type -> Type) :: Type -> Type -> Type
class (MonadReader b m, MonadReader a n) => Magnify m n b a | m -> b, n -> a, m a -> n, n b -> m

-- | This is an equivalent of <a>local</a> which lets you apply a getter to
--   your environment instead of merely applying a function (and it also
--   lets you change the type of the environment).
--   
--   <pre>
--   <a>local</a>   :: (r -&gt; r)   -&gt; <a>Reader</a> r a -&gt; <a>Reader</a> r a
--   <a>magnify</a> :: Getter r x -&gt; <a>Reader</a> x a -&gt; <a>Reader</a> r a
--   </pre>
--   
--   <a>magnify</a> works with <a>Reader</a> / <a>ReaderT</a>, <a>RWS</a> /
--   <a>RWST</a>, and <tt>(-&gt;)</tt>.
--   
--   Here's an example of <a>magnify</a> being used to work with a part of
--   a bigger config. First, the types:
--   
--   <pre>
--   data URL = URL {
--     _protocol :: Maybe String,
--     _path :: String }
--   
--   data Config = Config {
--     _base :: URL,
--     ... }
--   
--   makeLenses ''URL
--   makeLenses ''Config
--   </pre>
--   
--   Now, let's define a function which returns the base url:
--   
--   <pre>
--   getBase :: <a>Reader</a> Config String
--   getBase = do
--     protocol &lt;- <a>fromMaybe</a> "https" <a>&lt;$&gt;</a> <a>view</a> (base.protocol)
--     path     &lt;- <a>view</a> (base.path)
--     return (protocol ++ path)
--   </pre>
--   
--   With <a>magnify</a>, we can factor out <tt>base</tt>:
--   
--   <pre>
--   getBase = <a>magnify</a> base $ do
--     protocol &lt;- <a>fromMaybe</a> "https" <a>&lt;$&gt;</a> <a>view</a> protocol
--     path     &lt;- <a>view</a> path
--     return (protocol ++ path)
--   </pre>
--   
--   This concludes the example.
--   
--   Finally, you should know writing instances of <a>Magnify</a> for your
--   own types can be done as follows:
--   
--   <pre>
--   import <a>Lens.Micro.Mtl.Internal</a>
--   
--   type instance <a>Magnified</a> (MyReaderT r m) = <a>Magnified</a> (ReaderT r m)
--   
--   instance Monad m =&gt; <a>Magnify</a> (MyReaderT r m) (MyReaderT t m) r t where
--       <a>magnify</a> l (MyReaderT m) = MyReaderT (<a>magnify</a> l m)
--   </pre>
magnify :: Magnify m n b a => LensLike' (Magnified m c) a b -> m c -> n c
infixr 2 `magnify`

-- | Used by <a>Zoom</a> to <a>zoom</a> into <a>StateT</a>.
newtype Focusing m s a
Focusing :: m (s, a) -> Focusing m s a
[unfocusing] :: Focusing m s a -> m (s, a)

-- | Used by <a>Zoom</a> to <a>zoom</a> into <a>RWST</a>.
newtype FocusingWith w m s a
FocusingWith :: m (s, a, w) -> FocusingWith w m s a
[unfocusingWith] :: FocusingWith w m s a -> m (s, a, w)

-- | Used by <a>Zoom</a> to <a>zoom</a> into <a>WriterT</a>.
newtype FocusingPlus w k s a
FocusingPlus :: k (s, w) a -> FocusingPlus w k s a
[unfocusingPlus] :: FocusingPlus w k s a -> k (s, w) a

-- | Used by <a>Zoom</a> to <a>zoom</a> into <a>MaybeT</a> or <a>ListT</a>.
newtype FocusingOn f k s a
FocusingOn :: k (f s) a -> FocusingOn f k s a
[unfocusingOn] :: FocusingOn f k s a -> k (f s) a

-- | Used by <a>Zoom</a> to <a>zoom</a> into <a>ErrorT</a>.
newtype FocusingMay k s a
FocusingMay :: k (May s) a -> FocusingMay k s a
[unfocusingMay] :: FocusingMay k s a -> k (May s) a

-- | Used by <a>Zoom</a> to <a>zoom</a> into <a>ErrorT</a>.
newtype FocusingErr e k s a
FocusingErr :: k (Err e s) a -> FocusingErr e k s a
[unfocusingErr] :: FocusingErr e k s a -> k (Err e s) a

-- | Wrap a monadic effect with a phantom type argument.
newtype Effect m r a
Effect :: m r -> Effect m r a
[getEffect] :: Effect m r a -> m r

-- | Wrap a monadic effect with a phantom type argument. Used when
--   magnifying <a>RWST</a>.
newtype EffectRWS w st m s a
EffectRWS :: (st -> m (s, st, w)) -> EffectRWS w st m s a
[getEffectRWS] :: EffectRWS w st m s a -> st -> m (s, st, w)

-- | Make a <a>Monoid</a> out of <a>Maybe</a> for error handling.
newtype May a
May :: Maybe a -> May a
[getMay] :: May a -> Maybe a

-- | Make a <a>Monoid</a> out of <a>Either</a> for error handling.
newtype Err e a
Err :: Either e a -> Err e a
[getErr] :: Err e a -> Either e a
instance (GHC.Base.Monad m, GHC.Base.Monoid w) => Lens.Micro.Mtl.Internal.Magnify (Control.Monad.Trans.RWS.Strict.RWST b w s m) (Control.Monad.Trans.RWS.Strict.RWST a w s m) b a
instance (GHC.Base.Monad m, GHC.Base.Monoid w) => Lens.Micro.Mtl.Internal.Magnify (Control.Monad.Trans.RWS.Lazy.RWST b w s m) (Control.Monad.Trans.RWS.Lazy.RWST a w s m) b a
instance GHC.Base.Functor (Lens.Micro.Mtl.Internal.EffectRWS w st m s)
instance (GHC.Base.Monoid s, GHC.Base.Monoid w, GHC.Base.Monad m) => GHC.Base.Applicative (Lens.Micro.Mtl.Internal.EffectRWS w st m s)
instance GHC.Base.Monad m => Lens.Micro.Mtl.Internal.Magnify (Control.Monad.Trans.Reader.ReaderT b m) (Control.Monad.Trans.Reader.ReaderT a m) b a
instance GHC.Base.Functor (Lens.Micro.Mtl.Internal.Effect m r)
instance (GHC.Base.Monad m, GHC.Base.Monoid r) => GHC.Base.Monoid (Lens.Micro.Mtl.Internal.Effect m r a)
instance (GHC.Base.Monad m, GHC.Base.Semigroup r) => GHC.Base.Semigroup (Lens.Micro.Mtl.Internal.Effect m r a)
instance (GHC.Base.Monad m, GHC.Base.Monoid r) => GHC.Base.Applicative (Lens.Micro.Mtl.Internal.Effect m r)
instance Lens.Micro.Mtl.Internal.Magnify ((->) b) ((->) a) b a
instance Lens.Micro.Mtl.Internal.Magnify m n b a => Lens.Micro.Mtl.Internal.Magnify (Control.Monad.Trans.Identity.IdentityT m) (Control.Monad.Trans.Identity.IdentityT n) b a
instance GHC.Base.Monad z => Lens.Micro.Mtl.Internal.Zoom (Control.Monad.Trans.State.Strict.StateT s z) (Control.Monad.Trans.State.Strict.StateT t z) s t
instance GHC.Base.Monad z => Lens.Micro.Mtl.Internal.Zoom (Control.Monad.Trans.State.Lazy.StateT s z) (Control.Monad.Trans.State.Lazy.StateT t z) s t
instance Lens.Micro.Mtl.Internal.Zoom m n s t => Lens.Micro.Mtl.Internal.Zoom (Control.Monad.Trans.Reader.ReaderT e m) (Control.Monad.Trans.Reader.ReaderT e n) s t
instance Lens.Micro.Mtl.Internal.Zoom m n s t => Lens.Micro.Mtl.Internal.Zoom (Control.Monad.Trans.Identity.IdentityT m) (Control.Monad.Trans.Identity.IdentityT n) s t
instance (GHC.Base.Monoid w, GHC.Base.Monad z) => Lens.Micro.Mtl.Internal.Zoom (Control.Monad.Trans.RWS.Strict.RWST r w s z) (Control.Monad.Trans.RWS.Strict.RWST r w t z) s t
instance (GHC.Base.Monoid w, GHC.Base.Monad z) => Lens.Micro.Mtl.Internal.Zoom (Control.Monad.Trans.RWS.Lazy.RWST r w s z) (Control.Monad.Trans.RWS.Lazy.RWST r w t z) s t
instance (GHC.Base.Monoid w, Lens.Micro.Mtl.Internal.Zoom m n s t) => Lens.Micro.Mtl.Internal.Zoom (Control.Monad.Trans.Writer.Strict.WriterT w m) (Control.Monad.Trans.Writer.Strict.WriterT w n) s t
instance (GHC.Base.Monoid w, Lens.Micro.Mtl.Internal.Zoom m n s t) => Lens.Micro.Mtl.Internal.Zoom (Control.Monad.Trans.Writer.Lazy.WriterT w m) (Control.Monad.Trans.Writer.Lazy.WriterT w n) s t
instance Lens.Micro.Mtl.Internal.Zoom m n s t => Lens.Micro.Mtl.Internal.Zoom (Control.Monad.Trans.Maybe.MaybeT m) (Control.Monad.Trans.Maybe.MaybeT n) s t
instance Lens.Micro.Mtl.Internal.Zoom m n s t => Lens.Micro.Mtl.Internal.Zoom (Control.Monad.Trans.Except.ExceptT e m) (Control.Monad.Trans.Except.ExceptT e n) s t
instance GHC.Base.Functor (k (Lens.Micro.Mtl.Internal.Err e s)) => GHC.Base.Functor (Lens.Micro.Mtl.Internal.FocusingErr e k s)
instance GHC.Base.Applicative (k (Lens.Micro.Mtl.Internal.Err e s)) => GHC.Base.Applicative (Lens.Micro.Mtl.Internal.FocusingErr e k s)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Lens.Micro.Mtl.Internal.Err e a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Lens.Micro.Mtl.Internal.Err e a)
instance GHC.Base.Functor (k (Lens.Micro.Mtl.Internal.May s)) => GHC.Base.Functor (Lens.Micro.Mtl.Internal.FocusingMay k s)
instance GHC.Base.Applicative (k (Lens.Micro.Mtl.Internal.May s)) => GHC.Base.Applicative (Lens.Micro.Mtl.Internal.FocusingMay k s)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Lens.Micro.Mtl.Internal.May a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Lens.Micro.Mtl.Internal.May a)
instance GHC.Base.Functor (k (f s)) => GHC.Base.Functor (Lens.Micro.Mtl.Internal.FocusingOn f k s)
instance GHC.Base.Applicative (k (f s)) => GHC.Base.Applicative (Lens.Micro.Mtl.Internal.FocusingOn f k s)
instance GHC.Base.Functor (k (s, w)) => GHC.Base.Functor (Lens.Micro.Mtl.Internal.FocusingPlus w k s)
instance GHC.Base.Applicative (k (s, w)) => GHC.Base.Applicative (Lens.Micro.Mtl.Internal.FocusingPlus w k s)
instance GHC.Base.Monad m => GHC.Base.Functor (Lens.Micro.Mtl.Internal.FocusingWith w m s)
instance (GHC.Base.Monad m, GHC.Base.Monoid s, GHC.Base.Monoid w) => GHC.Base.Applicative (Lens.Micro.Mtl.Internal.FocusingWith w m s)
instance GHC.Base.Monad m => GHC.Base.Functor (Lens.Micro.Mtl.Internal.Focusing m s)
instance (GHC.Base.Monad m, GHC.Base.Monoid s) => GHC.Base.Applicative (Lens.Micro.Mtl.Internal.Focusing m s)


module Lens.Micro.Mtl

-- | <a>view</a> is a synonym for (<a>^.</a>), generalised for
--   <a>MonadReader</a> (we are able to use it instead of (<a>^.</a>) since
--   functions are instances of the <a>MonadReader</a> class):
--   
--   <pre>
--   &gt;&gt;&gt; view _1 (1, 2)
--   1
--   </pre>
--   
--   When you're using <a>Reader</a> for config and your config type has
--   lenses generated for it, most of the time you'll be using <a>view</a>
--   instead of <a>asks</a>:
--   
--   <pre>
--   doSomething :: (<a>MonadReader</a> Config m) =&gt; m Int
--   doSomething = do
--     thingy        &lt;- <a>view</a> setting1  -- same as “<a>asks</a> (<a>^.</a> setting1)”
--     anotherThingy &lt;- <a>view</a> setting2
--     ...
--   </pre>
view :: MonadReader s m => Getting a s a -> m a

-- | <a>preview</a> is a synonym for (<a>^?</a>), generalised for
--   <a>MonadReader</a> (just like <a>view</a>, which is a synonym for
--   (<a>^.</a>)).
--   
--   <pre>
--   &gt;&gt;&gt; preview each [1..5]
--   Just 1
--   </pre>
preview :: MonadReader s m => Getting (First a) s a -> m (Maybe a)

-- | <a>use</a> is (<a>^.</a>) (or <a>view</a>) which implicitly operates
--   on the state; for instance, if your state is a record containing a
--   field <tt>foo</tt>, you can write
--   
--   <pre>
--   x &lt;- <a>use</a> foo
--   </pre>
--   
--   to extract <tt>foo</tt> from the state. In other words, <a>use</a> is
--   the same as <a>gets</a>, but for getters instead of functions.
--   
--   The implementation of <a>use</a> is straightforward:
--   
--   <pre>
--   <a>use</a> l = <a>gets</a> (<a>view</a> l)
--   </pre>
--   
--   If you need to extract something with a fold or traversal, you need
--   <a>preuse</a>.
use :: MonadState s m => Getting a s a -> m a

-- | <a>preuse</a> is (<a>^?</a>) (or <a>preview</a>) which implicitly
--   operates on the state – it takes the state and applies a traversal (or
--   fold) to it to extract the 1st element the traversal points at.
--   
--   <pre>
--   <a>preuse</a> l = <a>gets</a> (<a>preview</a> l)
--   </pre>
preuse :: MonadState s m => Getting (First a) s a -> m (Maybe a)

-- | Modify state by applying a function to a part of the state. An
--   example:
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 %= (+1); _2 %= reverse) (1,"hello")
--   (2,"olleh")
--   </pre>
--   
--   Implementation:
--   
--   <pre>
--   l <a>%=</a> f = <a>modify</a> (l <a>%~</a> f)
--   </pre>
--   
--   If you also want to get the value before/after the modification, use
--   (<a>&lt;&lt;%=</a>)/(<a>&lt;%=</a>).
--   
--   There are a few specialised versions of (<a>%=</a>) which mimic C
--   operators:
--   
--   <ul>
--   <li>(<a>+=</a>) for addition</li>
--   <li>(<a>-=</a>) for substraction</li>
--   <li>(<a>*=</a>) for multiplication</li>
--   <li>(<a>//=</a>) for division</li>
--   </ul>
(%=) :: MonadState s m => ASetter s s a b -> (a -> b) -> m ()
infix 4 %=

-- | A synonym for (<a>%=</a>).
modifying :: MonadState s m => ASetter s s a b -> (a -> b) -> m ()

-- | Modify state by “assigning” a value to a part of the state.
--   
--   This is merely (<a>.~</a>) which works in <a>MonadState</a>:
--   
--   <pre>
--   l <a>.=</a> x = <a>modify</a> (l <a>.~</a> x)
--   </pre>
--   
--   If you also want to know the value that was replaced by (<a>.=</a>),
--   use (<a>&lt;&lt;.=</a>).
(.=) :: MonadState s m => ASetter s s a b -> b -> m ()
infix 4 .=

-- | A synonym for (<a>.=</a>).
assign :: MonadState s m => ASetter s s a b -> b -> m ()

-- | (<a>?=</a>) is a version of (<a>.=</a>) that wraps the value into
--   <a>Just</a> before setting.
--   
--   <pre>
--   l <a>?=</a> b = l <a>.=</a> Just b
--   </pre>
--   
--   It can be useful in combination with <a>at</a>.
(?=) :: MonadState s m => ASetter s s a (Maybe b) -> b -> m ()
infix 4 ?=

-- | (<a>&lt;~</a>) is a version of (<a>.=</a>) that takes a monadic value
--   (and then executes it and assigns the result to the lens).
--   
--   <pre>
--   l <a>&lt;~</a> mb = do
--     b &lt;- mb
--     l <a>.=</a> b
--   </pre>
(<~) :: MonadState s m => ASetter s s a b -> m b -> m ()
infixr 2 <~

-- | This can be used to chain lens operations using <tt>op=</tt> syntax
--   rather than <tt>op~</tt> syntax for simple non-type-changing cases.
--   &gt;&gt;&gt; (10,20) &amp; _1 .~ 30 &amp; _2 .~ 40 (30,40)
--   
--   <pre>
--   &gt;&gt;&gt; (10,20) &amp;~ do _1 .= 30; _2 .= 40
--   (30,40)
--   </pre>
--   
--   This does not support type-changing assignment, <i>e.g.</i>
--   
--   <pre>
--   &gt;&gt;&gt; (10,20) &amp; _1 .~ "hello"
--   ("hello",20)
--   </pre>
(&~) :: s -> State s a -> s
infixl 1 &~
(+=) :: (MonadState s m, Num a) => ASetter s s a a -> a -> m ()
infix 4 +=
(-=) :: (MonadState s m, Num a) => ASetter s s a a -> a -> m ()
infix 4 -=
(*=) :: (MonadState s m, Num a) => ASetter s s a a -> a -> m ()
infix 4 *=
(//=) :: (MonadState s m, Fractional a) => ASetter s s a a -> a -> m ()
infix 4 //=

-- | Modify state and return the modified (new) value.
--   
--   <pre>
--   l <a>&lt;%=</a> f = do
--     l <a>%=</a> f
--     <a>use</a> l
--   </pre>
(<%=) :: MonadState s m => LensLike ((,) b) s s a b -> (a -> b) -> m b
infix 4 <%=

-- | Set state and return new value.
--   
--   <pre>
--   l <a>&lt;.=</a> b = do
--     l <a>.=</a> b
--     return b
--   </pre>
(<.=) :: MonadState s m => LensLike ((,) b) s s a b -> b -> m b
infix 4 <.=

-- | (<a>&lt;?=</a>) is a version of (<a>&lt;.=</a>) that wraps the value
--   into <a>Just</a> before setting.
--   
--   <pre>
--   l <a>&lt;?=</a> b = do
--     l <a>.=</a> Just b
--     <a>return</a> b
--   </pre>
--   
--   It can be useful in combination with <a>at</a>.
(<?=) :: MonadState s m => LensLike ((,) b) s s a (Maybe b) -> b -> m b
infix 4 <?=

-- | Modify state and return the old value (i.e. as it was before the
--   modificaton).
--   
--   <pre>
--   l <a>&lt;&lt;%=</a> f = do
--     old &lt;- <a>use</a> l
--     l <a>%=</a> f
--     return old
--   </pre>
(<<%=) :: MonadState s m => LensLike ((,) a) s s a b -> (a -> b) -> m a
infix 4 <<%=

-- | Set state and return the old value.
--   
--   <pre>
--   l <a>&lt;&lt;.=</a> b = do
--     old &lt;- <a>use</a> l
--     l <a>.=</a> b
--     return old
--   </pre>
(<<.=) :: MonadState s m => LensLike ((,) a) s s a b -> b -> m a
infix 4 <<.=

-- | When you're in a state monad, this function lets you operate on a part
--   of your state. For instance, if your state was a record containing a
--   <tt>position</tt> field, after zooming <tt>position</tt> would become
--   your whole state (and when you modify it, the bigger structure would
--   be modified as well).
--   
--   (Your <a>State</a> / <a>StateT</a> or <a>RWS</a> / <a>RWST</a> can be
--   anywhere in the stack, but you can't use <a>zoom</a> with arbitrary
--   <a>MonadState</a> because it doesn't provide any methods to change the
--   type of the state. See <a>this issue</a> for details.)
--   
--   For the sake of the example, let's define some types first:
--   
--   <pre>
--   data Position = Position {
--     _x, _y :: Int }
--   
--   data Player = Player {
--     _position :: Position,
--     ... }
--   
--   data Game = Game {
--     _player :: Player,
--     _obstacles :: [Position],
--     ... }
--   
--   concat &lt;$&gt; mapM makeLenses [''Position, ''Player, ''Game]
--   </pre>
--   
--   Now, here's an action that moves the player north-east:
--   
--   <pre>
--   moveNE :: <a>State</a> Game ()
--   moveNE = do
--     player.position.x <a>+=</a> 1
--     player.position.y <a>+=</a> 1
--   </pre>
--   
--   With <a>zoom</a>, you can use <tt>player.position</tt> to focus just
--   on a part of the state:
--   
--   <pre>
--   moveNE :: <a>State</a> Game ()
--   moveNE = do
--     <a>zoom</a> (player.position) $ do
--       x <a>+=</a> 1
--       y <a>+=</a> 1
--   </pre>
--   
--   You can just as well use it for retrieving things out of the state:
--   
--   <pre>
--   getCoords :: <a>State</a> Game (Int, Int)
--   getCoords = <a>zoom</a> (player.position) ((,) <a>&lt;$&gt;</a> <a>use</a> x <a>&lt;*&gt;</a> <a>use</a> y)
--   </pre>
--   
--   Or more explicitly:
--   
--   <pre>
--   getCoords = <a>zoom</a> (player.position) $ do
--     x' &lt;- <a>use</a> x
--     y' &lt;- <a>use</a> y
--     return (x', y')
--   </pre>
--   
--   When you pass a traversal to <a>zoom</a>, it'll work as a loop. For
--   instance, here we move all obstacles:
--   
--   <pre>
--   moveObstaclesNE :: <a>State</a> Game ()
--   moveObstaclesNE = do
--     <a>zoom</a> (obstacles.<a>each</a>) $ do
--       x <a>+=</a> 1
--       y <a>+=</a> 1
--   </pre>
--   
--   If the action returns a result, all results would be combined with
--   <a>&lt;&gt;</a> – the same way they're combined when <a>^.</a> is
--   passed a traversal. In this example, <tt>moveObstaclesNE</tt> returns
--   a list of old coordinates of obstacles in addition to moving them:
--   
--   <pre>
--   moveObstaclesNE = do
--     xys &lt;- <a>zoom</a> (obstacles.<a>each</a>) $ do
--       -- Get old coordinates.
--       x' &lt;- <a>use</a> x
--       y' &lt;- <a>use</a> y
--       -- Update them.
--       x <a>.=</a> x' + 1
--       y <a>.=</a> y' + 1
--       -- Return a single-element list with old coordinates.
--       return [(x', y')]
--     ...
--   </pre>
--   
--   Finally, you might need to write your own instances of <a>Zoom</a> if
--   you use <tt>newtype</tt>d transformers in your monad stack. This can
--   be done as follows:
--   
--   <pre>
--   import <a>Lens.Micro.Mtl.Internal</a>
--   
--   type instance <a>Zoomed</a> (MyStateT s m) = <a>Zoomed</a> (StateT s m)
--   
--   instance Monad m =&gt; <a>Zoom</a> (MyStateT s m) (MyStateT t m) s t where
--       <a>zoom</a> l (MyStateT m) = MyStateT (<a>zoom</a> l m)
--   </pre>
zoom :: Zoom m n s t => LensLike' (Zoomed m c) t s -> m c -> n c
infixr 2 `zoom`

-- | This is an equivalent of <a>local</a> which lets you apply a getter to
--   your environment instead of merely applying a function (and it also
--   lets you change the type of the environment).
--   
--   <pre>
--   <a>local</a>   :: (r -&gt; r)   -&gt; <a>Reader</a> r a -&gt; <a>Reader</a> r a
--   <a>magnify</a> :: Getter r x -&gt; <a>Reader</a> x a -&gt; <a>Reader</a> r a
--   </pre>
--   
--   <a>magnify</a> works with <a>Reader</a> / <a>ReaderT</a>, <a>RWS</a> /
--   <a>RWST</a>, and <tt>(-&gt;)</tt>.
--   
--   Here's an example of <a>magnify</a> being used to work with a part of
--   a bigger config. First, the types:
--   
--   <pre>
--   data URL = URL {
--     _protocol :: Maybe String,
--     _path :: String }
--   
--   data Config = Config {
--     _base :: URL,
--     ... }
--   
--   makeLenses ''URL
--   makeLenses ''Config
--   </pre>
--   
--   Now, let's define a function which returns the base url:
--   
--   <pre>
--   getBase :: <a>Reader</a> Config String
--   getBase = do
--     protocol &lt;- <a>fromMaybe</a> "https" <a>&lt;$&gt;</a> <a>view</a> (base.protocol)
--     path     &lt;- <a>view</a> (base.path)
--     return (protocol ++ path)
--   </pre>
--   
--   With <a>magnify</a>, we can factor out <tt>base</tt>:
--   
--   <pre>
--   getBase = <a>magnify</a> base $ do
--     protocol &lt;- <a>fromMaybe</a> "https" <a>&lt;$&gt;</a> <a>view</a> protocol
--     path     &lt;- <a>view</a> path
--     return (protocol ++ path)
--   </pre>
--   
--   This concludes the example.
--   
--   Finally, you should know writing instances of <a>Magnify</a> for your
--   own types can be done as follows:
--   
--   <pre>
--   import <a>Lens.Micro.Mtl.Internal</a>
--   
--   type instance <a>Magnified</a> (MyReaderT r m) = <a>Magnified</a> (ReaderT r m)
--   
--   instance Monad m =&gt; <a>Magnify</a> (MyReaderT r m) (MyReaderT t m) r t where
--       <a>magnify</a> l (MyReaderT m) = MyReaderT (<a>magnify</a> l m)
--   </pre>
magnify :: Magnify m n b a => LensLike' (Magnified m c) a b -> m c -> n c
infixr 2 `magnify`
