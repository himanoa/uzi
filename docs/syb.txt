-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Scrap Your Boilerplate
--   
--   This package contains the generics system described in the <i>Scrap
--   Your Boilerplate</i> papers (see
--   <a>http://www.cs.uu.nl/wiki/GenericProgramming/SYB</a>). It defines
--   the <tt>Data</tt> class of types permitting folding and unfolding of
--   constructor applications, instances of this class for primitive types,
--   and a variety of traversals.
@package syb
@version 0.7.2.4


-- | This module provides a number of declarations for typical generic
--   function types, corresponding type case, and others.
module Data.Generics.Aliases

-- | Extend the identity function with a type-specific transformation. The
--   function created by <tt>mkT ext</tt> behaves like the identity
--   function on all arguments which cannot be cast to type <tt>b</tt>, and
--   like the function <tt>ext</tt> otherwise. The name <a>mkT</a> is short
--   for "make transformation".
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; mkT not True
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkT not 'a'
--   'a'
--   </pre>
mkT :: (Typeable a, Typeable b) => (b -> b) -> a -> a

-- | Extend a generic transformation by a type-specific transformation. The
--   function created by <tt>extT def ext</tt> behaves like the generic
--   transformation <tt>def</tt> if its argument cannot be cast to the type
--   <tt>b</tt>, and like the type-specific transformation <tt>ext</tt>
--   otherwise. The name <a>extT</a> is short for "extend transformation".
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; extT id not True
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extT id not 'a'
--   'a'
--   </pre>
extT :: (Typeable a, Typeable b) => (a -> a) -> (b -> b) -> a -> a

-- | The function created by <tt>mkQ def f</tt> returns the default result
--   <tt>def</tt> if its argument cannot be cast to type <tt>b</tt>,
--   otherwise it returns the result of applying <tt>f</tt> to its
--   argument. The name <a>mkQ</a> is short for "make query".
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; mkQ "default" (show :: Bool -&gt; String) True
--   "True"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkQ "default" (show :: Bool -&gt; String) ()
--   "default"
--   </pre>
mkQ :: (Typeable a, Typeable b) => r -> (b -> r) -> a -> r

-- | Extend a generic query by a type-specific query. The function created
--   by <tt>extQ def ext</tt> behaves like the generic query <tt>def</tt>
--   if its argument cannot be cast to the type <tt>b</tt>, and like the
--   type-specific query <tt>ext</tt> otherwise. The name <a>extQ</a> is
--   short for "extend query".
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; extQ (const True) not True
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extQ (const True) not 'a'
--   True
--   </pre>
extQ :: (Typeable a, Typeable b) => (a -> r) -> (b -> r) -> a -> r

-- | Extend the default monadic action <tt>pure :: Monad m =&gt; a -&gt; m
--   a</tt> by a type-specific monadic action. The function created by
--   <tt>mkM act</tt> behaves like <a>pure</a> if its argument cannot be
--   cast to type <tt>b</tt>, and like the monadic action <tt>act</tt>
--   otherwise. The name <a>mkM</a> is short for "make monadic
--   transformation".
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; mkM (\x -&gt; [x, not x]) True
--   [True,False]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkM (\x -&gt; [x, not x]) (5 :: Int)
--   [5]
--   </pre>
mkM :: (Monad m, Typeable a, Typeable b) => (b -> m b) -> a -> m a

-- | Extend a generic monadic transformation by a type-specific case. The
--   function created by <tt>extM def ext</tt> behaves like the monadic
--   transformation <tt>def</tt> if its argument cannot be cast to type
--   <tt>b</tt>, and like the monadic transformation <tt>ext</tt>
--   otherwise. The name <a>extM</a> is short for "extend monadic
--   transformation".
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; extM (\x -&gt; [x,x])(\x -&gt; [not x, x]) True
--   [False,True]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extM (\x -&gt; [x,x])(\x -&gt; [not x, x]) (5 :: Int)
--   [5,5]
--   </pre>
extM :: (Monad m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a

-- | Extend the default <a>MonadPlus</a> action <tt>const mzero</tt> by a
--   type-specific <a>MonadPlus</a> action. The function created by
--   <tt>mkMp act</tt> behaves like <tt>const mzero</tt> if its argument
--   cannot be cast to type <tt>b</tt>, and like the monadic action
--   <tt>act</tt> otherwise. The name <a>mkMp</a> is short for "make
--   MonadPlus transformation".
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; mkMp (\x -&gt; Just (not x)) True
--   Just False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkMp (\x -&gt; Just (not x)) 'a'
--   Nothing
--   </pre>
mkMp :: (MonadPlus m, Typeable a, Typeable b) => (b -> m b) -> a -> m a

-- | Extend a generic MonadPlus transformation by a type-specific case. The
--   function created by <tt>extMp def ext</tt> behaves like
--   <a>MonadPlus</a> transformation <tt>def</tt> if its argument cannot be
--   cast to type <tt>b</tt>, and like the transformation <tt>ext</tt>
--   otherwise. Note that <a>extMp</a> behaves exactly like <a>extM</a>.
--   The name <a>extMp</a> is short for "extend MonadPlus transformation".
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; extMp (\x -&gt; [x,x])(\x -&gt; [not x, x]) True
--   [False,True]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extMp (\x -&gt; [x,x])(\x -&gt; [not x, x]) (5 :: Int)
--   [5,5]
--   </pre>
extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a

-- | Make a generic reader from a type-specific case. The function created
--   by <tt>mkR f</tt> behaves like the reader <tt>f</tt> if an expression
--   of type <tt>a</tt> can be cast to type <tt>b</tt>, and like the
--   expression <tt>mzero</tt> otherwise. The name <a>mkR</a> is short for
--   "make reader".
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; mkR (Just True) :: Maybe Bool
--   Just True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkR (Just True) :: Maybe Int
--   Nothing
--   </pre>
mkR :: (MonadPlus m, Typeable a, Typeable b) => m b -> m a

-- | Extend a generic reader by a type-specific case. The reader created by
--   <tt>extR def ext</tt> behaves like the reader <tt>def</tt> if
--   expressions of type <tt>b</tt> cannot be cast to type <tt>a</tt>, and
--   like the reader <tt>ext</tt> otherwise. The name <a>extR</a> is short
--   for "extend reader".
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; extR (Just True) (Just 'a')
--   Just True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extR (Just True) (Just False)
--   Just False
--   </pre>
extR :: (Monad m, Typeable a, Typeable b) => m a -> m b -> m a

-- | Extend a generic builder by a type-specific case. The builder created
--   by <tt>extB def ext</tt> returns <tt>def</tt> if <tt>ext</tt> cannot
--   be cast to type <tt>a</tt>, and like <tt>ext</tt> otherwise. The name
--   <a>extB</a> is short for "extend builder".
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; extB True 'a'
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; extB True False
--   False
--   </pre>
extB :: (Typeable a, Typeable b) => a -> b -> a

-- | Flexible type extension
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; ext0 [1 :: Int, 2, 3] [True, False] :: [Int]
--   [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ext0 [1 :: Int, 2, 3] [4 :: Int, 5, 6] :: [Int]
--   [4,5,6]
--   </pre>
ext0 :: (Typeable a, Typeable b) => c a -> c b -> c a

-- | Generic transformations, i.e., take an "a" and return an "a"
type GenericT = forall a. Data a => a -> a

-- | The type synonym <a>GenericT</a> has a polymorphic type, and can
--   therefore not appear in places where monomorphic types are expected,
--   for example in a list. The newtype <a>GenericT'</a> wraps
--   <a>GenericT</a> in a newtype to lift this restriction.
newtype GenericT'
GT :: GenericT -> GenericT'
[unGT] :: GenericT' -> GenericT

-- | Generic queries of type "r", i.e., take any "a" and return an "r"
type GenericQ r = forall a. Data a => a -> r

-- | The type synonym <a>GenericQ</a> has a polymorphic type, and can
--   therefore not appear in places where monomorphic types are expected,
--   for example in a list. The newtype <a>GenericQ'</a> wraps
--   <a>GenericQ</a> in a newtype to lift this restriction.
newtype GenericQ' r
GQ :: GenericQ r -> GenericQ' r
[unGQ] :: GenericQ' r -> GenericQ r

-- | Generic monadic transformations, i.e., take an "a" and compute an "a"
type GenericM m = forall a. Data a => a -> m a

-- | The type synonym <a>GenericM</a> has a polymorphic type, and can
--   therefore not appear in places where monomorphic types are expected,
--   for example in a list. The newtype <a>GenericM'</a> wraps
--   <a>GenericM</a> in a newtype to lift this restriction.
newtype GenericM' m
GM :: GenericM m -> GenericM' m
[unGM] :: GenericM' m -> GenericM m

-- | Generic readers, say monadic builders, i.e., produce an "a" with the
--   help of a monad "m".
type GenericR m = forall a. Data a => m a

-- | Generic builders i.e., produce an "a".
type GenericB = forall a. Data a => a

-- | The general scheme underlying generic functions assumed by gfoldl;
--   there are isomorphisms such as GenericT = Generic T.
type Generic c = forall a. Data a => a -> c a

-- | The type synonym <a>Generic</a> has a polymorphic type, and can
--   therefore not appear in places where monomorphic types are expected,
--   for example in a list. The data type <a>Generic'</a> wraps
--   <a>Generic</a> in a data type to lift this restriction.
data Generic' c
Generic' :: Generic c -> Generic' c
[unGeneric'] :: Generic' c -> Generic c

-- | Left-biased choice on maybes
--   
--   <h3><b>Examples</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; orElse Nothing Nothing
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; orElse Nothing (Just 'a')
--   Just 'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; orElse (Just 'a') Nothing
--   Just 'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; orElse (Just 'a') (Just 'b')
--   Just 'a'
--   </pre>
orElse :: Maybe a -> Maybe a -> Maybe a

-- | Recover from the failure of monadic transformation by identity
recoverMp :: MonadPlus m => GenericM m -> GenericM m

-- | Recover from the failure of monadic query by a constant
recoverQ :: MonadPlus m => r -> GenericQ (m r) -> GenericQ (m r)

-- | Choice for monadic transformations
choiceMp :: MonadPlus m => GenericM m -> GenericM m -> GenericM m

-- | Choice for monadic queries
choiceQ :: MonadPlus m => GenericQ (m r) -> GenericQ (m r) -> GenericQ (m r)

-- | Flexible type extension
ext1 :: (Data a, Typeable t) => c a -> (forall d. Data d => c (t d)) -> c a

-- | Type extension of transformations for unary type constructors
ext1T :: (Data d, Typeable t) => (forall e. Data e => e -> e) -> (forall f. Data f => t f -> t f) -> d -> d

-- | Type extension of monadic transformations for type constructors
ext1M :: (Monad m, Data d, Typeable t) => (forall e. Data e => e -> m e) -> (forall f. Data f => t f -> m (t f)) -> d -> m d

-- | Type extension of queries for type constructors
ext1Q :: (Data d, Typeable t) => (d -> q) -> (forall e. Data e => t e -> q) -> d -> q

-- | Type extension of readers for type constructors
ext1R :: (Monad m, Data d, Typeable t) => m d -> (forall e. Data e => m (t e)) -> m d

-- | Type extension of builders for type constructors
ext1B :: (Data a, Typeable t) => a -> (forall b. Data b => t b) -> a

-- | Flexible type extension
ext2 :: (Data a, Typeable t) => c a -> (forall d1 d2. (Data d1, Data d2) => c (t d1 d2)) -> c a

-- | Type extension of transformations for unary type constructors
ext2T :: (Data d, Typeable t) => (forall e. Data e => e -> e) -> (forall d1 d2. (Data d1, Data d2) => t d1 d2 -> t d1 d2) -> d -> d

-- | Type extension of monadic transformations for type constructors
ext2M :: (Monad m, Data d, Typeable t) => (forall e. Data e => e -> m e) -> (forall d1 d2. (Data d1, Data d2) => t d1 d2 -> m (t d1 d2)) -> d -> m d

-- | Type extension of queries for type constructors
ext2Q :: (Data d, Typeable t) => (d -> q) -> (forall d1 d2. (Data d1, Data d2) => t d1 d2 -> q) -> d -> q

-- | Type extension of readers for type constructors
ext2R :: (Monad m, Data d, Typeable t) => m d -> (forall d1 d2. (Data d1, Data d2) => m (t d1 d2)) -> m d

-- | Type extension of builders for type constructors
ext2B :: (Data a, Typeable t) => a -> (forall d1 d2. (Data d1, Data d2) => t d1 d2) -> a


-- | "Scrap your boilerplate" --- Generic programming in Haskell. See
--   <a>http://www.cs.uu.nl/wiki/GenericProgramming/SYB</a>. This module
--   provides the <a>Data</a> class with its primitives for generic
--   programming, which is now defined in <tt>Data.Data</tt>. Therefore
--   this module simply re-exports <tt>Data.Data</tt>.
module Data.Generics.Basics


-- | This module provides generic builder functions. These functions
--   construct values of a given type.
module Data.Generics.Builders

-- | Construct the empty value for a datatype. For algebraic datatypes, the
--   leftmost constructor is chosen.
empty :: forall a. Data a => a

-- | Return a list of values of a datatype. Each value is one of the
--   possible constructors of the datatype, populated with <a>empty</a>
--   values.
constrs :: forall a. Data a => [a]


-- | "Scrap your boilerplate" --- Generic programming in Haskell See
--   <a>http://www.cs.uu.nl/wiki/GenericProgramming/SYB</a>. The present
--   module contains thirteen <a>Data</a> instances which are considered
--   dubious (either because the types are abstract or just not meant to be
--   traversed). Instances in this module might change or disappear in
--   future releases of this package.
--   
--   (This module does not export anything. It really just defines
--   instances.)
module Data.Generics.Instances
instance Data.Data.Data GHC.Types.TyCon
instance Data.Data.Data Data.Data.DataType
instance Data.Data.Data GHC.IO.Handle.Types.Handle
instance Data.Typeable.Internal.Typeable a => Data.Data.Data (GHC.Stable.StablePtr a)
instance Data.Data.Data GHC.Conc.Sync.ThreadId
instance Data.Typeable.Internal.Typeable a => Data.Data.Data (GHC.Conc.Sync.TVar a)
instance Data.Typeable.Internal.Typeable a => Data.Data.Data (GHC.MVar.MVar a)
instance Data.Typeable.Internal.Typeable a => Data.Data.Data (GHC.Conc.Sync.STM a)
instance (Data.Typeable.Internal.Typeable s, Data.Typeable.Internal.Typeable a) => Data.Data.Data (GHC.ST.ST s a)
instance Data.Typeable.Internal.Typeable a => Data.Data.Data (GHC.IORef.IORef a)
instance Data.Typeable.Internal.Typeable a => Data.Data.Data (GHC.Types.IO a)
instance (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (a -> b)


-- | "Scrap your boilerplate" --- Generic programming in Haskell See
--   <a>http://www.cs.uu.nl/wiki/GenericProgramming/SYB</a>. The present
--   module provides frequently used generic traversal schemes.
module Data.Generics.Schemes

-- | Apply a transformation everywhere in bottom-up manner
everywhere :: (forall a. Data a => a -> a) -> forall a. Data a => a -> a

-- | Apply a transformation everywhere in top-down manner
everywhere' :: (forall a. Data a => a -> a) -> forall a. Data a => a -> a

-- | Variation on everywhere with an extra stop condition
everywhereBut :: GenericQ Bool -> GenericT -> GenericT

-- | Monadic variation on everywhere
everywhereM :: forall m. Monad m => GenericM m -> GenericM m

-- | Apply a monadic transformation at least somewhere
somewhere :: forall m. MonadPlus m => GenericM m -> GenericM m

-- | Summarise all nodes in top-down, left-to-right order
everything :: forall r. (r -> r -> r) -> GenericQ r -> GenericQ r

-- | Variation of "everything" with an added stop condition
everythingBut :: forall r. (r -> r -> r) -> GenericQ (r, Bool) -> GenericQ r

-- | Summarise all nodes in top-down, left-to-right order, carrying some
--   state down the tree during the computation, but not left-to-right to
--   siblings.
everythingWithContext :: forall s r. s -> (r -> r -> r) -> GenericQ (s -> (r, s)) -> GenericQ r

-- | Get a list of all entities that meet a predicate
listify :: Typeable r => (r -> Bool) -> GenericQ [r]

-- | Look up a subterm by means of a maybe-typed filter
something :: GenericQ (Maybe u) -> GenericQ (Maybe u)

-- | Bottom-up synthesis of a data structure; 1st argument z is the initial
--   element for the synthesis; 2nd argument o is for reduction of results
--   from subterms; 3rd argument f updates the synthesised data according
--   to the given term
synthesize :: forall s t. s -> (t -> s -> s) -> GenericQ (s -> t) -> GenericQ t

-- | Compute size of an arbitrary data structure
gsize :: Data a => a -> Int

-- | Count the number of immediate subterms of the given term
glength :: GenericQ Int

-- | Determine depth of the given term
gdepth :: GenericQ Int

-- | Determine the number of all suitable nodes in a given term
gcount :: GenericQ Bool -> GenericQ Int

-- | Determine the number of all nodes in a given term
gnodecount :: GenericQ Int

-- | Determine the number of nodes of a given type in a given term
gtypecount :: Typeable a => a -> GenericQ Int

-- | Find (unambiguously) an immediate subterm of a given type
gfindtype :: (Data x, Typeable y) => x -> Maybe y


-- | "Scrap your boilerplate" --- Generic programming in Haskell See
--   <a>http://www.cs.uu.nl/wiki/GenericProgramming/SYB</a>. The present
--   module provides generic operations for text serialisation of terms.
module Data.Generics.Text

-- | Generic show: an alternative to "deriving Show"
gshow :: Data a => a -> String

-- | Generic shows
gshows :: Data a => a -> ShowS

-- | Generic read: an alternative to "deriving Read"
gread :: Data a => ReadS a


-- | "Scrap your boilerplate" --- Generic programming in Haskell See
--   <a>http://www.cs.uu.nl/wiki/GenericProgramming/SYB</a>. The present
--   module provides support for multi-parameter traversal, which is also
--   demonstrated with generic operations like equality.
module Data.Generics.Twins

-- | gfoldl with accumulation
gfoldlAccum :: Data d => (forall e r. Data e => a -> c (e -> r) -> e -> (a, c r)) -> (forall g. a -> g -> (a, c g)) -> a -> d -> (a, c d)

-- | gmapT with accumulation
gmapAccumT :: Data d => (forall e. Data e => a -> e -> (a, e)) -> a -> d -> (a, d)

-- | gmapM with accumulation
gmapAccumM :: (Data d, Monad m) => (forall e. Data e => a -> e -> (a, m e)) -> a -> d -> (a, m d)

-- | gmapQl with accumulation
gmapAccumQl :: Data d => (r -> r' -> r) -> r -> (forall e. Data e => a -> e -> (a, r')) -> a -> d -> (a, r)

-- | gmapQr with accumulation
gmapAccumQr :: Data d => (r' -> r -> r) -> r -> (forall e. Data e => a -> e -> (a, r')) -> a -> d -> (a, r)

-- | gmapQ with accumulation
gmapAccumQ :: Data d => (forall e. Data e => a -> e -> (a, q)) -> a -> d -> (a, [q])

-- | Applicative version
gmapAccumA :: forall b d a. (Data d, Applicative a) => (forall e. Data e => b -> e -> (b, a e)) -> b -> d -> (b, a d)

-- | Twin map for transformation
gzipWithT :: GenericQ GenericT -> GenericQ GenericT

-- | Twin map for monadic transformation
gzipWithM :: Monad m => GenericQ (GenericM m) -> GenericQ (GenericM m)

-- | Twin map for queries
gzipWithQ :: GenericQ (GenericQ r) -> GenericQ (GenericQ [r])

-- | Generic equality: an alternative to "deriving Eq"
geq :: Data a => a -> a -> Bool

-- | Generic zip controlled by a function with type-specific branches
gzip :: GenericQ (GenericM Maybe) -> GenericQ (GenericM Maybe)

-- | Generic comparison: an alternative to "deriving Ord"
gcompare :: Data a => a -> a -> Ordering


-- | "Scrap your boilerplate" --- Generic programming in Haskell See
--   <a>http://www.cs.uu.nl/wiki/GenericProgramming/SYB</a>. To scrap your
--   boilerplate it is sufficient to import the present module, which
--   simply re-exports all themes of the Data.Generics library.
module Data.Generics


-- | Convenience alias for <a>Data.Generics</a>.
module Generics.SYB


-- | Convenience alias for <a>Data.Generics.Aliases</a>.
module Generics.SYB.Aliases


-- | Convenience alias for <a>Data.Generics.Basics</a>.
module Generics.SYB.Basics


-- | Convenience alias for <a>Data.Generics.Builders</a>.
module Generics.SYB.Builders


-- | Convenience alias for <a>Data.Generics.Instances</a>.
module Generics.SYB.Instances


-- | Convenience alias for <a>Data.Generics.Schemes</a>.
module Generics.SYB.Schemes


-- | Convenience alias for <a>Data.Generics.Text</a>.
module Generics.SYB.Text


-- | Convenience alias for <a>Data.Generics.Twins</a>.
module Generics.SYB.Twins
